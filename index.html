<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>MacroControlAPP</title>
  <meta name="theme-color" content="#111111" />
  <link rel="manifest" href="manifest.webmanifest" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="MacroControl" />
  <meta name="format-detection" content="telephone=no" />
  <link rel="apple-touch-icon" href="icon-192.png" />
  <style>
    html{ -webkit-text-size-adjust:100%; }
    body{ overscroll-behavior-y:none; }
    input,select,textarea,button{ font-size:16px; }

    
    /* iOS: alinear input time y select (altura similar) */
    input[type="time"], select{ min-height:48px; height:48px; }
    #weekChips .miniBtn.activeDay{background:linear-gradient(180deg,#23c26b,#128a49);border:none;color:#fff;}
:root{--bg:#0f1115;--card:#161a22;--muted:#9aa4b2;--text:#e6e9ef;--acc:#4da3ff;--line:#242a36;}
    *{box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial;}
    body{margin:0;background:var(--bg);color:var(--text);padding:16px;padding-bottom:92px;padding-top:calc(env(safe-area-inset-top) + 16px);}
    h1{font-size:18px;margin:0 0 10px;}
    .muted{color:var(--muted);font-size:13px;line-height:1.35}
    .row{display:flex;gap:10px;flex-wrap:wrap;}
    .card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:12px;flex:1;min-width:280px;position:relative;}
    label{display:block;font-size:12px;color:var(--muted);margin:10px 0 6px;}
    input,select,button,textarea{width:100%;border-radius:12px;border:1px solid #2a3242;background:#0c0f14;color:var(--text);padding:10px;font-size:16px;}
    textarea{min-height:92px;resize:vertical;}
    button{background:#0c0f14;cursor:pointer;}
    button.primary{background:linear-gradient(180deg,#1a7cff,#0b5bd6);border:none;}
    button.success{background:linear-gradient(180deg,#23c26b,#128a49);border:none;}
    button.danger{background:linear-gradient(180deg,#ff4d4d,#c91f1f);border:none;}
    .seg{display:flex;gap:8px;flex-wrap:wrap;}
    .seg button{flex:1;min-width:120px}
    .seg button.active{outline:2px solid var(--acc);border-color:transparent;}
    /* Ventana m√≥vil: chips d√≠as */
    /* Week chips: 7 botones centrados y encajados (sin que el √∫ltimo se salga) */
    .weekChips{display:flex;gap:6px;overflow:visible; padding-bottom:4px;}
    .weekChips::-webkit-scrollbar{display:none;}
    .weekChips button{flex:1 1 0;min-width:0;height:40px;padding:8px 8px;border-radius:14px;}
    .weekChips button.activeDay{background:linear-gradient(180deg,rgba(38,208,124,.42),rgba(38,208,124,.18));border-color:rgba(38,208,124,.65);}

    /* iOS: alinear inputs de hora y selects */
    input[type="time"], select{ min-height:48px; height:48px; }

    /* Week chips */
    #weekChips button[disabled]{opacity:.55;cursor:default;}
    #def15Chip,#def30Chip,#adh15Chip,#adh30Chip{display:none;}

    .pill{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;background:#0c0f14;border:1px solid #2a3242;color:var(--muted);font-size:12px;}
    .kpi{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:10px;}
    .box{background:#0c0f14;border:1px solid #2a3242;border-radius:12px;padding:10px;}
    .num{font-size:18px;font-weight:700;}
    .lbl{font-size:12px;color:var(--muted);}
    .hr{height:1px;background:var(--line);margin:10px 0;}
    .list{display:flex;flex-direction:column;gap:8px;margin-top:10px;}
    .item{display:flex;justify-content:space-between;gap:10px;background:#0c0f14;border:1px solid #2a3242;border-radius:12px;padding:10px;}
    .item b{font-size:16px;}
    .item small{color:var(--muted);}
    .right{text-align:right;}
    .tabs{position:fixed;left:0;right:0;bottom:0;background:#0b0d12;border-top:1px solid var(--line);display:flex;gap:8px;padding:10px 12px;padding-bottom:calc(10px + env(safe-area-inset-bottom));}
    .tabs button{flex:1;border-radius:14px;padding:10px;border:1px solid var(--line);background:#0f1115;color:var(--muted);}
    .tabs button.active{color:var(--text);border-color:#2a3242;outline:2px solid #2a3242;}
    .two{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
    .stack{display:flex;flex-direction:column;gap:10px;}
    .delBtn{width:auto;padding:8px 10px;border-radius:10px;border:1px solid #2a3242;background:#0c0f14;}
    .status{border-radius:14px;padding:12px;border:1px solid #2a3242;background:#0c0f14;}
    .status.good{outline:2px solid rgba(0,255,120,.25);border-color:rgba(0,255,120,.35);}
    .status.ok{outline:2px solid rgba(255,200,0,.18);border-color:rgba(255,200,0,.35);}
    .status.bad{outline:2px solid rgba(255,70,70,.18);border-color:rgba(255,70,70,.35);}
    .status .badge{display:inline-flex;align-items:center;gap:8px;font-weight:700}
    .dot{width:10px;height:10px;border-radius:999px;display:inline-block}
    .dot.good{background:rgb(0,255,120)}
    .dot.ok{background:rgb(255,200,0)}
    .dot.bad{background:rgb(255,70,70)}

    details{background:#0c0f14;border:1px solid #2a3242;border-radius:12px;padding:10px;}
    summary{cursor:pointer;color:var(--text);font-weight:700;list-style:none;}
    summary::-webkit-details-marker{display:none;}
    /* Panel plegable Macros OK (pantalla principal) */
    .detailsPanel > summary{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
    }
    #macrosOkSummaryLine{font-weight:600;font-size:12px;white-space:nowrap;}

    .hint{color:var(--muted);font-size:12px;line-height:1.35;margin-top:6px;}

    .groupSummary{
      display:flex;justify-content:space-between;align-items:center;gap:10px;
      padding:8px 10px;border-radius:12px;border:1px solid #2a3242;background:#0c0f14;
    }
    .groupSummary b{font-size:13px;}
    .groupSummary small{color:var(--muted);}
    .groupWrap{display:flex;flex-direction:column;gap:8px;margin-top:8px;}
    .miniBtn{width:auto;white-space:nowrap;padding:8px 10px;border-radius:10px;border:1px solid #2a3242;background:#0c0f14;color:var(--text);}

    /* Macro status (P/C/F consumido) */
    .macroBox.good{outline:2px solid rgba(0,255,120,.25);border-color:rgba(0,255,120,.35);}
    .macroBox.ok{outline:2px solid rgba(255,200,0,.18);border-color:rgba(255,200,0,.35);}
    .macroBox.bad{outline:2px solid rgba(255,70,70,.18);border-color:rgba(255,70,70,.35);}
    .macroBadge{display:flex;align-items:center;gap:8px;margin-top:6px;font-size:12px;color:var(--muted);}
    .macroBadge b{color:var(--text);font-weight:700;}

    .topPills{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px;}

    /* Drawer full-screen */
    .drawerBack{
      position:fixed;inset:0;z-index:9999;
      background:#0b0d12;
      display:none;
      overflow:auto;
      -webkit-overflow-scrolling:touch;
      padding:16px;
      padding-top:calc(16px + env(safe-area-inset-top));
      padding-bottom:calc(16px + env(safe-area-inset-bottom));
    }
    .drawer{max-width:820px;margin:0 auto;}
    .drawerTop{display:flex;justify-content:space-between;align-items:center;gap:10px;margin-bottom:10px;}
    .iconBtn{width:auto;padding:10px 12px;border-radius:12px;border:1px solid var(--line);background:#0f1115;color:var(--text);}
    .tagBtn{width:auto;min-width:auto;flex:0 0 auto;padding:8px 10px;border-radius:12px;border:1px solid #2a3242;background:#0c0f14;color:var(--text);}
    #saveFood{ margin-top:12px; }

    .searchRow{display:flex;gap:8px;align-items:center;}

    /* --- Ajustes m√≥viles (iPhone) --- */
    input[type="time"]{max-width:100%;}
    .card{overflow:hidden;}

    @media (max-width: 430px){
      body{padding:12px;padding-bottom:88px;padding-top:calc(env(safe-area-inset-top) + 12px);}
      .card{padding:10px;border-radius:13px;}
      h1{font-size:17px;}
      .num{font-size:17px;}
      .tabs{padding:9px 10px;padding-bottom:calc(9px + env(safe-area-inset-bottom));}
      .tabs button{padding:9px;border-radius:13px;}

      /* Chips de ventana m√≥vil: evitar que el d√≠a se salga */
      .weekChips button{min-width:0;height:44px;padding:6px 6px;font-size:13px;white-space:normal;line-height:1.05;}
      #weekChips .miniBtn{display:flex;flex-direction:column;justify-content:center;align-items:center;}

      /* Inputs/selects algo m√°s compactos */
      input,select,button,textarea{border-radius:12px;padding:9px;font-size:16px;}
      input[type="time"], select{min-height:46px;height:46px;}
    }
    .searchRow input{flex:1;}
    .foodListScroller{max-height:48vh; overflow:auto; -webkit-overflow-scrolling:touch; padding-right:2px;}
  
    /* Popover buscador global */
    .pop{display:none;position:absolute;top:58px;right:18px;z-index:50;min-width:320px;max-width:520px;}
    .pop[aria-hidden="false"]{display:block;}
    .popInner{background:rgba(22,26,34,.98);border:1px solid var(--line);border-radius:14px;padding:12px;box-shadow:0 10px 30px rgba(0,0,0,.35);backdrop-filter: blur(8px);}
    @media (max-width:520px){ .pop{left:12px;right:12px;min-width:auto;} }

  
    /* Chips hist√≥rico */
    .pill.good{border-color:rgba(38,208,124,.35); background:rgba(38,208,124,.08);}
    .pill.bad{border-color:rgba(255,77,77,.35); background:rgba(255,77,77,.08);}
    .pill.mid{border-color:rgba(255,193,7,.28); background:rgba(255,193,7,.07);}

  
    /* Macro progress bars (V2) */
    .macroBars{margin-top:12px;display:flex;flex-direction:column;gap:10px;}
    .barRow{padding:10px 10px 8px;border:1px solid #232a38;border-radius:14px;background:rgba(12,15,20,.55);}
    .barHead{display:flex;align-items:center;justify-content:space-between;gap:10px;}
    .barLabel{font-weight:700;letter-spacing:.2px;}
    .barVal{font-variant-numeric:tabular-nums;color:var(--text);opacity:.95}
    .barTrack{height:10px;border-radius:999px;background:#0b0e13;border:1px solid #242a36;overflow:hidden;margin-top:8px;}
    .barFill{height:100%;width:0%;border-radius:999px;transition:width .25s ease;}
    .barFill.good{background:rgba(0,255,120,.85);}
    .barFill.mid{background:rgba(255,200,0,.85);}
    .barFill.bad{background:rgba(255,70,70,.85);}
    .barSub{margin-top:6px;font-size:12px;color:var(--muted);}


    /* Balance bar */
    .balTrack{position:relative;height:14px;border-radius:999px;background:#0b0e13;border:1px solid #242a36;margin-top:10px;overflow:hidden;}
    .balZero{position:absolute;left:50%;top:0;bottom:0;width:2px;background:rgba(255,255,255,.18);}
    .balDot{position:absolute;top:50%;transform:translateY(-50%);width:14px;height:14px;border-radius:50%;background:var(--acc);box-shadow:0 0 0 4px rgba(102,179,255,.15);}
    .balScale{display:flex;justify-content:space-between;margin-top:6px;font-size:12px;}


    /* Registro visual por comidas */
    details{border-radius:16px;}
    details > summary.groupSummary{list-style:none;cursor:pointer;display:flex;align-items:center;justify-content:space-between;gap:12px;padding:12px 12px;border:1px solid #232a38;border-radius:16px;background:rgba(12,15,20,.55);}
    details[open] > summary.groupSummary{border-bottom-left-radius:10px;border-bottom-right-radius:10px;}
    summary.groupSummary::-webkit-details-marker{display:none;}
    .groupSummary small{opacity:.85}
    .groupWrap{padding:10px 10px 6px;border:1px solid #232a38;border-top:none;border-bottom-left-radius:16px;border-bottom-right-radius:16px;background:rgba(10,12,18,.35);}
    .item{padding:10px 0;border-bottom:1px solid rgba(255,255,255,.06);}
    .item:last-child{border-bottom:none;}


    #foodsControlBox > summary{padding:2px 0;}


    /* iOS anti-zoom on inputs */
    input, select, textarea, button { font-size:16px; }
    /* Add tab UX */
    .recentFoods{display:flex;gap:8px;flex-wrap:wrap;margin:10px 0 6px;}
    .recentFoods .chip{padding:8px 10px;border-radius:999px;border:1px solid #2a3242;background:#0c0f14;color:var(--text);font-size:13px;}
    .unitToggle{display:flex;gap:8px;align-items:center;margin-top:8px;}
    .unitToggle .miniBtn{min-width:60px}
    .unitToggle .miniBtn.active{border-color:rgba(0,255,120,.85);box-shadow:0 0 0 2px rgba(0,255,120,.12) inset;}
    .foodListScroller.hidden{display:none;}


    /* ======= DEV OCR MODAL (r48) ======= */
    .modalBack{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.55);z-index:9999;padding:16px;}
    .modalBox{width:min(560px,100%);max-height:88vh;overflow:auto;background:rgba(18,18,18,.98);border:1px solid rgba(255,255,255,.10);border-radius:16px;padding:14px;}
    .modalTop{display:flex;align-items:center;gap:10px;}
    .modalTop b{font-size:16px}
    .modalBox .field{margin-top:10px}
    .modalBox label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
    .modalBox input[type="text"], .modalBox input[type="number"], .modalBox textarea{
      width:100%;padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.25);color:var(--text);font-size:16px;
    }
    .modalBox textarea{min-height:120px;font-size:13px;line-height:1.25}
    .modalActions{display:flex;gap:10px;justify-content:flex-end;margin-top:14px;flex-wrap:wrap}
    .previewLine{margin-top:10px;padding:10px;border-radius:12px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.08)}

</style>
</head>

<body>

  

  <h1>MacroControlAPP</h1>
  <div id="weekChips" class="weekChips" style="margin:10px 0 14px;"></div>
  <div class="muted" style="margin-bottom:12px;">
    </div>

  <!-- Drawer ALIMENTOS (full-screen) -->
  <div class="drawerBack" id="drawerBack">
    <div class="drawer">
      <div class="drawerTop">
        <b id="drawerTitle">Alimentos</b><span id="devBadge" class="pill" style="display:none; margin-left:auto;">DEV</span>
        <button class="iconBtn" id="closeDrawer" type="button">Cerrar</button>
      </div>

      <!-- 1) CONTROL ARRIBA (lo pediste as√≠) -->
      <details class="card" id="foodsControlBox" style="margin-bottom:12px;" >
  <summary style="list-style:none;cursor:pointer;display:flex;align-items:center;justify-content:space-between;">
    <b>Control</b>
    <span class="muted">Importar/Exportar</span>
  </summary>
  <div style="margin-top:10px;">

<div id="devLockedHint" class="muted" style="margin-top:6px;">Modo desarrollador BLOQUEADO. Mant√©n pulsado ‚ÄúAlimentos‚Äù para desbloquear.</div>
<div id="devControlActions" style="display:none;">
<div class="seg">
          <button id="exportFoods" type="button">Exportar JSON</button>
          <button id="importFoodsBtn" type="button">Importar JSON</button>
        </div>
        <!-- DEV tool (r48): OCR label scanner -->
        <div class="seg" style="margin-top:10px;">
          <button id="ocrScanBtn" type="button">Escanear etiqueta (OCR)</button>
        </div>
        <div class="muted" style="margin-top:6px;">
          DEV: crea/actualiza un alimento por 100 g a partir de una foto de la etiqueta.
        </div>

        <input id="importFoodsFile" type="file" accept="application/json" style="display:none;" />
        <div class="muted" style="margin-top:8px;">
          Consejo: exporta primero, edita el JSON en ordenador y reimporta.
        </div>
        <div id="devBackupBlock" style="margin-top:12px; display:none;">
          <hr style="border:none;border-top:1px solid rgba(255,255,255,.08);margin:12px 0;">
          <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:6px;">
            <b>Backup r√°pido (DEV)</b>
            <span class="muted">Estado completo</span>
          </div>
          <div class="seg">
            <button id="exportBackup" type="button">Exportar backup</button>
            <button id="importBackupBtn" type="button">Importar backup</button>
          </div>
          <div class="seg" style="margin-top:8px;">
            <button id="restoreLastBackup" type="button">Restaurar √∫ltimo</button>
            <button id="makeBackupNow" type="button">Guardar copia</button>
          </div>
          <input id="importBackupFile" type="file" accept="application/json" style="display:none;" />
          <div class="muted" style="margin-top:8px;">
            Exporta antes de actualizar. En iPhone se guarda en Archivos y luego puedes importarlo en segundos.
          </div>
        </div>

        <div id="devRulesBlock" style="margin-top:12px; display:none;">
          <hr style="border:none;border-top:1px solid rgba(255,255,255,.08);margin:12px 0;">
          <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:6px;">
            <b>Rules Engine (DEV)</b>
            <span class="muted">Maridajes & caps</span>
          </div>
          <div class="seg">
            <button id="exportRules" type="button">Exportar reglas</button>
            <button id="importRulesBtn" type="button">Importar reglas</button>
            <button id="viewLastTrace" type="button">Ver trace Cuadrar D√≠a</button>
            <button id="clearLastTrace" type="button">Borrar trace</button>
          </div>
          <div class="seg" style="margin-top:8px;">
            <button id="resetRules" type="button">Restaurar por defecto</button>
          </div>
          <input id="importRulesFile" type="file" accept="application/json" style="display:none;" />
          <div class="muted" style="margin-top:8px;">
            Consejo: exporta, edita el JSON y reimporta. Si el archivo es inv√°lido, se ignora.
          </div>
        </div>
</div>
  </div>
</details>
      </div>

      <div class="card" style="margin-bottom:12px;">
        <label>A√±adir / editar alimento</label>
        <input id="f_id" placeholder="id (sin espacios)" />
        <input id="f_name" placeholder="Nombre" />

        <label>Unidad base</label>
        <select id="f_baseUnit">
          <option value="100g" selected>por 100 g</option>
          <option value="100ml" disabled>por 100 ml (legacy)</option>
          <option value="unit">por unidad</option>
        </select>

        <label>Macros por unidad base</label>
        <div class="stack">
          <input id="f_kcal" type="number" placeholder="kcal" />
          <input id="f_p" type="number" placeholder="P" />
        </div>
        <div class="two">
          <input id="f_c" type="number" placeholder="C" />
          <input id="f_f" type="number" placeholder="F" />
        </div>

        <label>Gramos por unidad (si aplica)</label>
        <input id="f_unitGrams" type="number" placeholder="Ej: 60 (pan cristal)" />

        <label>Tags (r√°pidos)</label>
        <div class="seg" style="gap:6px;">
          <button type="button" class="tagBtn" data-tag="protein">Prote√≠na</button>
          <button type="button" class="tagBtn" data-tag="carb">Carbo</button>
          <button type="button" class="tagBtn" data-tag="fat">Grasa</button>
        </div>
        <div class="seg" style="gap:6px;margin-top:8px;">
          <button type="button" class="tagBtn" data-tag="desayuno_ok">ü•£ Desayuno</button>
          <button type="button" class="tagBtn" data-tag="comida_ok">üçó Comida</button>
          <button type="button" class="tagBtn" data-tag="merienda_ok">üçé Merienda</button>
          <button type="button" class="tagBtn" data-tag="cena_ok">üåô Cena</button>
        </div>
        <div class="seg" style="gap:6px;margin-top:8px;">
          <button type="button" class="tagBtn" data-tag="pre_ok">‚ö° Pre</button>
          <button type="button" class="tagBtn" data-tag="post_ok">‚úÖ Post</button>
        </div>

        <div id="tagsTextBlock" style="display:none;">
        <label>Tags (texto)</label>
        <input id="f_tags" placeholder="protein, carb, fat, desayuno_ok..." />
        <div class="hint">Puedes usar botones o editar el texto. Se sincroniza.</div>
        </div>

        <button class="primary" id="saveFood" type="button">Guardar alimento</button>
        <button class="danger" id="deleteFood" type="button" style="margin-top:8px;display:none;">Eliminar alimento</button>
        <button id="toggleHideFood" type="button" style="margin-top:8px;display:none;">Ocultar / Mostrar (root)</button>
        <div style="height:12px;"></div>
        <div class="muted" style="margin-top:8px;">
          Lo guardado aqu√≠ se almacena como ‚Äúusuario‚Äù y se conserva aunque actualices el c√≥digo.
        </div>
      </div>

      <!-- 2) LISTA ABAJO (plegable + buscador) -->
      <details open>
        <summary>Lista de alimentos (toca uno para editar)</summary>
        <div class="card" style="margin-top:10px;">
          <div class="searchRow">
            <input id="foodsSearch" placeholder="Buscar por nombre o id..." />
            <button id="clearFoodsSearch" type="button" class="iconBtn">X</button>
          </div>
          <div class="foodListScroller">
            <div class="list" id="foodsList"></div>
          </div>
          <div class="hint">Si la lista es grande, usa el buscador (arriba).</div>
        </div>
      </details>
    </div>
  </div>

  <!-- D√çA -->
  <section id="screen-day">
    <div class="row">
      <div class="card">
        <div class="topPills">
          <div class="pill">Fecha: <b id="dateChip">‚Äî</b></div>
          <div class="pill">Peso: <b id="weightChip">‚Äî</b></div>
          <div class="pill" id="stageChipPill" style="cursor:pointer;">Objetivo: <b id="stageChip">‚Äî</b></div>
          <button class="iconBtn" id="openFoods" type="button" title="Alimentos">‚ò∞</button>
          <button class="iconBtn" id="toggleGlobalSearch" type="button" title="Buscar">üîé</button>
          <button class="iconBtn" id="openStatsTop" type="button" title="Estad√≠sticas">üìä</button>
        </div>

        <div id="globalSearchPop" class="pop" aria-hidden="true">
          <div class="popInner">
            <div class="row" style="gap:8px;">
              <input id="globalFoodSearch" placeholder="Buscar alimento (id o nombre)‚Ä¶" />
              <button class="iconBtn" id="globalFoodSearchBtn" type="button">Buscar</button>
            </div>
            <div class="muted" style="margin-top:6px;font-size:12px;">Enter para buscar ¬∑ Esc para cerrar</div>
          </div>
        </div>

        <!-- ETAPA -->
        <details id="stageBox">
          <summary style="display:flex;justify-content:space-between;align-items:center;gap:10px;">
            <span>ETAPA</span>
            <span class="pill"><b id="stageChipRight">‚Äî</b></span>
          </summary>

          <label style="margin-top:10px;">Objetivo (cambia cada 30 d√≠as)</label>
          <div class="seg" id="modeSeg"></div>

          <label>Nivel diario (cambiable a diario)</label>
          <div class="seg" id="levelSeg"></div>

          <div class="seg" style="margin-top:10px;">
            <button id="overrideStage" type="button">Override etapa</button>
            <button class="primary" id="saveStage" type="button">Guardar etapa</button>
          </div>
          <div class="hint" id="stageLockHint">‚Äî</div>
          <div class="hint">Tip: toca el chip ‚ÄúObjetivo‚Äù arriba para alternar Suave/Medio/Agresivo.</div>
        </details>

        <div class="hr"></div>

        <!-- PERFIL -->
        <details id="profileBox">
          <summary>PERFIL DE COMPOSICI√ìN CORPORAL</summary>
          <div class="two" style="margin-top:10px;">
            <div>
              <label>Sexo</label>
              <select id="sex">
                <option value="m" selected>Hombre</option>
                <option value="f">Mujer</option>
              </select>
            </div>
            <div>
              <label>Edad</label>
              <input id="age" type="number" inputmode="numeric" placeholder="35" />
            </div>
          </div>

          <div class="two">
            <div>
              <label>Altura (cm)</label>
              <input id="heightCm" type="number" inputmode="numeric" placeholder="175" />
            </div>
            <div>
              <label>Peso (kg) <span id="weightLockHint" class="muted"></span></label>
              <input id="weightKg" type="number" inputmode="decimal" placeholder="69" />
              <div class="seg" style="margin-top:8px;">
                <button id="overrideWeight" type="button">Override peso</button>
                <button class="primary" id="saveProfile" type="button">Guardar perfil</button>
              </div>
              <div class="hint">El peso se bloquea 10 d√≠as tras actualizarlo (salvo override).</div>
            </div>
          </div>
        </details>

        <div class="hr"></div>

        <!-- NEAT -->
        <label>NEAT diario</label>
        <div class="two">
          <div>
            <label>Pasos (opcional)</label>
            <input id="steps" type="number" inputmode="numeric" placeholder="Ej: 10500" />
          </div>
          <div>
            <label>Actividad (NEAT)</label>
            <select id="neatLevel">
              <option value="low">Baja</option>
              <option value="med">Media</option>
              <option value="high" selected>Alta</option>
            </select>
          </div>
        </div>
        <div class="muted" id="neatInfo" style="margin-top:6px;">‚Äî</div>

        <div class="hr"></div>

        <div class="stack">
          <div>
            <label>Hora entreno</label>
            <input id="trainTime" type="time" />
          </div>
          <div>
            <label>WOD</label>
            <select id="wod">
              <option value="0">Sin WOD</option>
              <option value="300">Ligero (+300)</option>
              <option value="350" selected>Normal (+350)</option>
              <option value="450">Alto (+450)</option>
            </select>
          </div>
        </div>

        <label>Calor√≠as activas (dispositivo) *</label>
        <input id="cardioKcal" type="number" inputmode="numeric" placeholder="Ej: 421" />
        <div class="muted" style="margin-top:6px;">
          * Se descuenta autom√°ticamente un <b>8%</b> por seguridad (sobreestimaci√≥n t√≠pica).
        </div>

        <div class="hr"></div>

        <!-- BOTONES FIJOS (como pediste): Guardar + P√°nico al lado -->
        <div class="seg" style="margin-top:0;">
          <button class="primary" id="saveDay" type="button">Guardar ajustes del d√≠a</button>
          <button class="danger" id="panicBtn" type="button" title="Aplica d√©ficit fijo de emergencia">P√°nico</button>
        </div>
        <div class="muted" style="margin-top:8px;">Prote√≠na objetivo = 2,5 g/kg (fase actual).</div>
      </div>

      <div class="card">
        <div class="status" id="dayStatusBox">
          <div class="badge" id="dayStatusBadge"><span class="dot ok"></span> Estado del d√≠a: ‚Äî</div>
          <button id="openStats" type="button" class="delBtn" style="position:absolute;top:12px;right:12px;" title="Ver estad√≠sticas">üìä</button>
          <div class="muted" id="dayStatusDetail" style="margin-top:6px;">‚Äî</div>

          <div id="macroBars" class="macroBars" aria-label="Progreso de macros">
            <div class="barRow" data-m="p">
              <div class="barHead"><span class="barLabel">ü•© Prote√≠na</span><span class="barVal" id="barPVal">‚Äî</span></div>
              <div class="barTrack"><div class="barFill" id="barPFill"></div></div>
              <div class="barSub" id="barPSub">‚Äî</div>
            </div>
            <div class="barRow" data-m="f">
              <div class="barHead"><span class="barLabel">üßà Grasas</span><span class="barVal" id="barFVal">‚Äî</span></div>
              <div class="barTrack"><div class="barFill" id="barFFill"></div></div>
              <div class="barSub" id="barFSub">‚Äî</div>
            </div>
            <div class="barRow" data-m="c">
              <div class="barHead"><span class="barLabel">üçö Carbohidratos</span><span class="barVal" id="barCVal">‚Äî</span></div>
              <div class="barTrack"><div class="barFill" id="barCFill"></div></div>
              <div class="barSub" id="barCSub">‚Äî</div>
            </div>
            <div class="barRow" data-m="kcal">
              <div class="barHead"><span class="barLabel">üî• Calor√≠as</span><span class="barVal" id="barKVal">‚Äî</span></div>
              <div class="barTrack"><div class="barFill" id="barKFill"></div></div>
              <div class="barSub" id="barKSub">‚Äî</div>
            </div>
          </div>

          <div class="chipRow" style="display:flex;flex-wrap:wrap;gap:8px;margin-top:10px;">
            <div class="pill" id="def7Chip">D√©ficit 7d: <b id="def7Val">‚Äî</b></div>
            <div class="pill" id="def15Chip">15d: <b id="def15Val">‚Äî</b></div>
            <div class="pill" id="def30Chip">30d: <b id="def30Val">‚Äî</b></div>
            <div class="pill" id="adh7Chip">Adherencia 7d: <b id="adh7Val">‚Äî</b></div>
            <div class="pill" id="adh15Chip">15d: <b id="adh15Val">‚Äî</b></div>
            <div class="pill" id="adh30Chip">30d: <b id="adh30Val">‚Äî</b></div>
          </div>

        </div>

          <div class="card" id="adviceCard" style="margin-top:12px;">
            <div class="row" style="align-items:center;justify-content:space-between;">
              <b>üîé Recomendaci√≥n</b>
              <span class="muted" id="adviceHint">‚Äî</span>
            </div>
            <div id="macroAdviceText" style="margin-top:8px;line-height:1.35;">‚Äî</div>
          </div>

          <div class="card" id="balanceCard" style="margin-top:12px;">
            <b>‚öñÔ∏è Balance energ√©tico</b>
            <div class="muted" style="margin-top:4px;" id="balanceText">‚Äî</div>
            <div class="balTrack" aria-label="Balance energ√©tico">
              <div class="balZero"></div>
              <div class="balDot" id="balDot"></div>
            </div>
            <div class="balScale muted"><span>-800</span><span>0</span><span>+800</span></div>
          </div>

<div class="hr"></div>

        <div class="kpi">
          <div class="box"><div class="num" id="goalKcal">‚Äî</div><div class="lbl">Objetivo kcal</div></div>
          <div class="box"><div class="num" id="eatenKcal">‚Äî</div><div class="lbl">Consumidas</div></div>
          <div class="box"><div class="num" id="remKcal">‚Äî</div><div class="lbl" id="remKcalLbl">Faltan</div></div>
          <div class="box"><div class="num" id="tdeeKcal">‚Äî</div><div class="lbl">TDEE estimado</div></div>
        </div>

        <div class="hr"></div>

        <div class="kpi">
          
        </div>

        <div class="hr"></div>

        <!-- MACROS OK -->
        <details id="macrosOkPanel" class="detailsPanel">
          <summary>
            <span>Cuadrar D√≠a ¬∑ Modo plan</span>
            <span class="muted" id="macrosOkSummaryLine">‚Äî</span>
          </summary>

          <div class="muted" id="macrosOkContext">Pulsa ‚ÄúCuadrar D√≠a‚Äù para cuadrar los slots pendientes (respetando lo ya registrado).</div>
          <div class="list" id="macrosOkList"></div>
          <div class="seg">
            <button id="macrosOkGen" type="button">Cuadrar D√≠a</button>
            <button class="success" id="macrosOkConfirm" type="button">‚úÖ Confirmar</button>
          </div>
          <div class="muted" style="margin-top:6px;">La sugerencia no se a√±ade al registro hasta confirmar. Toca un √≠tem para ajustar cantidad.</div>
        </details>

        <div class="hr"></div>

        <label>Recomendaci√≥n din√°mica (ventana actual)</label>
        <div class="muted" id="recContext">‚Äî</div>
        <div class="list" id="recList"></div>
        <div class="seg">
          <button id="regenRec" type="button">Regenerar</button>
          <button id="addRecToLog" type="button">A√±adir recomendaci√≥n</button>
        </div>

        <div class="hr"></div>

        <label>Registro de hoy (por bloques)</label>
        <div class="muted">Edita tocando un item. Borra con üóë o escribe <b>DEL</b>.</div>
        <div class="list" id="logList"></div>

        <div class="seg">
          <button id="clearToday" type="button">Borrar d√≠a</button>
        </div>
      </div>
    </div>
  </section>

  <!-- A√ëADIR -->
  <section id="screen-add" style="display:none;">
    <div class="row">
      <div class="card">
        <label>üçó Comida</label>
        <select id="mealSlot">
          <option value="desayuno">ü•£ Desayuno</option>
          <option value="comida" selected>üçó Comida</option>
          <option value="merienda">üçé Merienda</option>
          <option value="cena">üåô Cena</option>
          <option value="post_entreno">Post-entreno</option>
          <option value="pre_entreno">Pre-entreno</option>
        </select>

        <label>Buscar</label>
        <input id="foodSearch" placeholder="Escribe para filtrar..." />
        <div id="addStatusBar" class="addStatusBar">
          <div class="row">
            <div class="pill"><span class="k">üî•</span><span class="v" id="addRemK">‚Äî</span></div>
            <div class="pill"><span class="k">ü•©</span><span class="v" id="addRemP">‚Äî</span></div>
            <div class="pill"><span class="k">üçö</span><span class="v" id="addRemC">‚Äî</span></div>
            <div class="pill"><span class="k">ü•ë</span><span class="v" id="addRemF">‚Äî</span></div>
          </div>
        </div>

        <!-- (Eliminado) Lista r√°pida bajo buscar: generaba ruido y no aportaba -->

        <!-- Lista visible (se acab√≥ el ‚Äúselect vac√≠o‚Äù en iOS) -->
        <label>Lista (toca para seleccionar)</label>
        <div class="foodListScroller" id="addFoodScroller" style="max-height:46vh;">
          <div class="list" id="addFoodList"></div>
        </div>
        <div class="hint">Se filtra con el buscador. El alimento seleccionado queda arriba en ‚ÄúProducto‚Äù.</div>

        <label>Producto (seleccionado)</label>
        <select id="foodPick"></select>

        <label>Cantidad</label>
        <div class="two">
          <select id="qtyType" style="display:none;">
            <option value="g" selected>g</option>
            <option value="unit">ud</option>
          </select>
          <div class="unitToggle" id="unitToggle">
            <button type="button" class="miniBtn" id="btnUnitG">g</button>
            <button type="button" class="miniBtn" id="btnUnitU">ud</button>
          </div>
          <input id="qty" type="number" inputmode="numeric" placeholder="Ej: 200" />
        </div>

        <button class="primary" id="addItem" type="button">A√±adir</button>

        <div class="hr"></div>

        <label>Texto r√°pido</label>
        <textarea id="quickText" placeholder="Ej:
pollo_pechuga 200g
gnocchi 180g
pan_cristal 2u"></textarea>
        <button id="parseQuick" type="button">Verificar y a√±adir</button>
        <div class="muted" style="margin-top:8px;">Acepta g/u/ml. Usa id o parte del nombre.</div>
      </div>
    </div>
  </section>

  
  <!-- Estad√≠sticas (detalle) -->
  <div id="statsModal" style="display:none;position:fixed;inset:0;z-index:50;background:rgba(0,0,0,.55);padding:calc(env(safe-area-inset-top) + 16px) 16px calc(env(safe-area-inset-bottom) + 16px) 16px;">
    <div class="card" style="max-width:720px;margin:40px auto 0;position:relative;">
      <button id="closeStats" class="delBtn" type="button" style="position:absolute;top:12px;right:12px;">‚úï</button>
      <h2 style="margin:0 0 8px;font-size:16px;">Estad√≠sticas</h2>
      <div class="muted" style="margin-bottom:10px;">Solo cuenta d√≠as <b>pasados</b> con registro (no incluye d√≠as futuros planificados).</div>
      <div class="kpi">
        <div class="box"><div class="num" id="statDef7">‚Äî</div><div class="lbl">D√©ficit 7d</div></div>
        <div class="box"><div class="num" id="statDef15">‚Äî</div><div class="lbl">D√©ficit 15d</div></div>
        <div class="box"><div class="num" id="statDef30">‚Äî</div><div class="lbl">D√©ficit 30d</div></div>
        <div class="box"><div class="num" id="statAdh7">‚Äî</div><div class="lbl">Adherencia 7d</div></div>
        <div class="box"><div class="num" id="statAdh15">‚Äî</div><div class="lbl">Adherencia 15d</div></div>
        <div class="box"><div class="num" id="statAdh30">‚Äî</div><div class="lbl">Adherencia 30d</div></div>
      </div>
      <div class="hr"></div>
      <div class="status" id="statDevBox">
        <div class="badge"><span class="dot ok" id="statDevDot"></span> Correcci√≥n</div>
        <div class="muted" id="statDevText" style="margin-top:6px;">‚Äî</div>
      </div>
    </div>
  </div>

<div class="tabs">
    <button id="tabDay" class="active" type="button">D√≠a</button>
    <button id="tabAdd" type="button">A√±adir</button>
  </div>


  <!-- ======= MODAL OCR (DEV) - r48 ======= -->
  <div class="modalBack" id="ocrBack" aria-hidden="true">
    <div class="modalBox" role="dialog" aria-modal="true" aria-label="Esc√°ner nutricional">
      <div class="modalTop">
        <b>Esc√°ner nutricional</b>
        <span id="ocrConf" class="pill" style="margin-left:auto;display:none;">OCR</span>
        <button class="iconBtn" id="ocrClose" type="button">‚úï</button>
      </div>

      <div class="field">
        <label for="ocrName">Nombre del producto (obligatorio)</label>
        <input id="ocrName" type="text" placeholder="Ej: Queso batido 0% Hacendado" />
      </div>

      <div class="field">
        <label>Foto de la etiqueta</label>
        <div class="seg">
          <button id="ocrPickBtn" type="button">Hacer foto / seleccionar imagen</button>
          <input id="ocrFile" type="file" accept="image/*"  style="display:none;" />
        </div>
        <div id="ocrFileHint" class="muted" style="margin-top:6px;">Sube una foto n√≠tida (por 100 g si es posible).</div>
      </div>

      <details class="card" id="ocrTextBox" style="margin-top:12px;">
        <summary style="list-style:none;cursor:pointer;display:flex;align-items:center;justify-content:space-between;">
          <b>Texto OCR detectado</b>
          <span class="muted">ver/ocultar</span>
        </summary>
        <div style="margin-top:10px;">
          <textarea id="ocrText" placeholder="Aqu√≠ se mostrar√° el texto OCR‚Ä¶"></textarea>
        </div>
      </details>

      <div class="field" style="margin-top:12px;">
        <label>Macros por 100 g (editable)</label>
        <div class="grid2" style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
          <div>
            <label for="ocrFat">Grasas (g)</label>
            <input id="ocrFat" type="number" step="0.1" min="0" max="100" placeholder="Ej: 1.5" />
          </div>
          <div>
            <label for="ocrProtein">Prote√≠nas (g)</label>
            <input id="ocrProtein" type="number" step="0.1" min="0" max="100" placeholder="Ej: 6" />
          </div>
          <div>
            <label for="ocrCarbs">Carbohidratos (g)</label>
            <input id="ocrCarbs" type="number" step="0.1" min="0" max="100" placeholder="Ej: 7" />
          </div>
          <div>
            <label for="ocrKcal">kcal (opcional)</label>
            <input id="ocrKcal" type="number" step="1" min="0" max="900" placeholder="Ej: 120" />
          </div>
        </div>

        <div id="ocrPreview" class="previewLine muted" style="display:none;"></div>
        <div id="ocrWarn" class="muted" style="margin-top:8px;display:none;"></div>
      </div>

      <div class="modalActions">
        <button id="ocrCancel" type="button">Cancelar</button>
        <button id="ocrSave" type="button">Guardar alimento</button>
      </div>
    </div>
  </div>

<script>
// Debug visible en iOS si algo rompe el render
window.addEventListener('error', function(e){
  try{
    var box=document.getElementById('jsErrorBox');
    if(!box){
      box=document.createElement('div');
      box.id='jsErrorBox';
      box.style.cssText='position:fixed;left:12px;right:12px;top:12px;z-index:9999;background:#2b1111;border:1px solid #ff4d4d;color:#fff;padding:10px;border-radius:12px;font-size:12px;white-space:pre-wrap;';
      document.body.appendChild(box);
    }
    box.textContent='Error JS: '+(e.message||'')+'\n'+(e.filename||'')+':'+(e.lineno||0)+':'+(e.colno||0);
  }catch(_){ }
});

(()=> {
  // =========================
  // STORAGE KEYS (estables)
  // =========================
  
  // ======= DEV OCR CONFIG (r48) =======
  // OCR_ENDPOINT: endpoint OCR (multipart/form-data). Expected response:
  // {
  //   "text": "full_ocr_text",
  //   "per100g": {"fat": 1.5, "protein": 6, "carbs": 7, "kcal": 120},
  //   "confidence": 0..1
  // }
  // If backend returns only "text", we parse locally (regex ES/EN).
  const OCR_ENDPOINT = "https://api.ocr.space/parse/image"; // OCR.space endpoint (DEV)
  const OCR_SPACE_APIKEY = "K84237061588957"; // ‚ö† Visible in client (DEV only)
  const OCR_SPACE_LANG = "spa"; // "spa" or "eng"
  const OCR_SPACE_ENGINE = "2"; // OCR engine 2 often better for labels

const LS = {
    mode: 'mc_mode',
    modeLegacy: 'mc_mode_v9',
    settings: 'mc_settings',
    settingsLegacy: 'mc_settings_v9',
    logs: 'mc_logs',
    logsLegacy: 'mc_logs_v9',
    lastDate: 'mc_lastDate',
    lastDateLegacy: 'mc_lastDate_v9',
    profile: 'mc_profile',
    rulesEngine: 'mc_rules_engine',
    foodsRoot: 'mc_foods_root',
    foodsUser: 'mc_foods_user',
    foodsLegacy: 'mc_foods_v8'
  };

  // =========================
  // DATA VERSIONING (migraciones seguras)
  // =========================
  const DATA_VERSION = 2;
  const LS_VERSION_KEY = 'mc_data_version';

  const migrateIfNeeded = ()=>{
    const cur = Number(localStorage.getItem(LS_VERSION_KEY) || 0);
    if(cur === DATA_VERSION) return;

    // v2: claves estables (sin _v9) + copia desde legacy si existe (para no perder historial tras actualizar).
    try{
      if(!localStorage.getItem(LS.mode) && localStorage.getItem(LS.modeLegacy)) localStorage.setItem(LS.mode, localStorage.getItem(LS.modeLegacy));
      if(!localStorage.getItem(LS.settings) && localStorage.getItem(LS.settingsLegacy)) localStorage.setItem(LS.settings, localStorage.getItem(LS.settingsLegacy));
      if(!localStorage.getItem(LS.logs) && localStorage.getItem(LS.logsLegacy)) localStorage.setItem(LS.logs, localStorage.getItem(LS.logsLegacy));
      if(!localStorage.getItem(LS.lastDate) && localStorage.getItem(LS.lastDateLegacy)) localStorage.setItem(LS.lastDate, localStorage.getItem(LS.lastDateLegacy));
    }catch(_){}

    // Garantizar estructuras base sin romper datos existentes.
    try{
      const logs = loadJSON(LS.logs, {});
      if(typeof logs !== 'object' || Array.isArray(logs)) saveJSON(LS.logs, {});
      const settings = loadJSON(LS.settings, {});
      if(typeof settings !== 'object' || Array.isArray(settings)) saveJSON(LS.settings, {});
    }catch(_){}
    localStorage.setItem(LS_VERSION_KEY, String(DATA_VERSION));
  };

  const WEIGHT_LOCK_DAYS = 10;
  const STAGE_LOCK_DAYS = 30;
  const CARDIO_DISCOUNT = 0.08; // <-- m√°ximo 8% (lo acordado)
  let weightOverride = false;
  let stageOverride = false;

  // Objetivos
  const MODES=[
    {key:'deficit',label:'D√©ficit'},
    {key:'maint',label:'Mantenimiento'},
    {key:'surplus',label:'Super√°vit'}
  ];

  const LEVELS={
    deficit:[
      {key:'d250',label:'Suave (‚àí250)',adj:-250},
      {key:'d350',label:'Medio (‚àí350)',adj:-350},
      {key:'d430',label:'Agresivo (‚àí430)',adj:-430}
    ],
    maint:[{key:'m0',label:'0',adj:0}],
    surplus:[
      {key:'s150',label:'Suave (+150)',adj:150},
      {key:'s250',label:'Medio (+250)',adj:250},
      {key:'s350',label:'Agresivo (+350)',adj:350}
    ],
  };

  const PAL = { low: 1.25, med: 1.35, high: 1.45 };

  // ======= DEFAULT FOODS (ra√≠z) =======
  const DEFAULT_FOODS = [
    {id:'pollo_pechuga', name:'Pechuga pollo filete', baseUnit:'100g', kcal:108, p:22, c:0.5, f:1.8, unitGrams:null, tags:['protein','comida_ok','cena_ok','post_ok']},
    {id:'gnocchi', name:'Gnocchi Hacendado', baseUnit:'100g', kcal:174, p:4.5, c:37.6, f:0.4, unitGrams:null, tags:['carb','comida_ok','cena_ok','pre_ok','post_ok']},
    {id:'queso_batido_0', name:'Queso batido 0% (ed√≠talo)', baseUnit:'100g', kcal:44, p:8, c:4, f:0, unitGrams:null, tags:['protein','desayuno_ok','merienda_ok','post_ok']},
    {id:'tortitas_maiz_choco', name:'Tortitas ma√≠z chocolate', baseUnit:'unit', kcal:155, p:2, c:21, f:6.8, unitGrams:null, tags:['carb','desayuno_ok','merienda_ok','pre_ok']},
    {id:'pan_cristal', name:'Pan cristal (1u=60g)', baseUnit:'100g', kcal:228, p:7.3, c:43, f:2.3, unitGrams:60, tags:['carb','desayuno_ok','comida_ok','cena_ok','pre_ok','post_ok']},
    {id:'claras', name:'Claras l√≠quidas', baseUnit:'100ml', kcal:42, p:11, c:0.5, f:0, unitGrams:null, tags:['protein','desayuno_ok','comida_ok','cena_ok','post_ok']},
    {id:'huevo_M', name:'Huevo M (1u‚âà60g)', baseUnit:'100g', kcal:138, p:12.5, c:0.7, f:9.5, unitGrams:60, tags:['protein','fat','desayuno_ok','comida_ok','cena_ok','post_ok']},
    {id:'banana', name:'Banana', baseUnit:'100g', kcal:89, p:1, c:23, f:0, unitGrams:null, tags:['carb','desayuno_ok','merienda_ok','pre_ok','post_ok']},
    {id:'freson', name:'Fres√≥n', baseUnit:'100g', kcal:32, p:0.7, c:7, f:0, unitGrams:null, tags:['carb','desayuno_ok','merienda_ok','post_ok']},
    {id:'chocolate_85', name:'Chocolate 85%', baseUnit:'100g', kcal:597, p:12, c:20, f:49, unitGrams:null, tags:['fat','merienda_ok','cena_ok']}
  ];

  // ======= HELPERS =======
  const $=id=>document.getElementById(id);
  // =========================
  // DEV MODE (bloquea acciones peligrosas)
  // =========================
  const DEV_MODE_KEY = 'mc_dev_mode_v1';
  const DEV_HIDDEN_KEY = 'mc_foods_hidden_v1'; // para ocultar foodsRoot sin tocarlos
  const DEV_PIN = atob('MDk1NA=='); // 0954

  const isDev = ()=> localStorage.getItem(DEV_MODE_KEY)==='1';
  const setDev = (on)=>{
    localStorage.setItem(DEV_MODE_KEY, on ? '1' : '0');
    applyDevUI();
  };

  const loadHiddenIds = ()=> loadJSON(DEV_HIDDEN_KEY, []);
  const saveHiddenIds = (arr)=> saveJSON(DEV_HIDDEN_KEY, Array.isArray(arr)?arr:[]);
  const isHiddenId = (id)=> loadHiddenIds().includes(id);
  const toggleHiddenId = (id)=>{
    const cur = loadHiddenIds();
    const next = cur.includes(id) ? cur.filter(x=>x!==id) : [...cur, id];
    saveHiddenIds(next);
  };

  const applyDevUI = ()=>{
    const dev = isDev();
    const badge = $('devBadge');
    if(badge) badge.style.display = dev ? 'inline-flex' : 'none';

    const ctrlActions = $('devControlActions');
    const ctrlHint = $('devLockedHint');
    if(ctrlActions) ctrlActions.style.display = dev ? '' : 'none';
    if(ctrlHint) ctrlHint.style.display = dev ? 'none' : '';

    const backupBlock = $('devBackupBlock');
    if(backupBlock) backupBlock.style.display = dev ? '' : 'none';

    const rulesBlock = $('devRulesBlock');
    if(rulesBlock) rulesBlock.style.display = dev ? '' : 'none';

    const delBtn = $('deleteFood');
    const hideBtn = $('toggleHideFood');
    if(delBtn) delBtn.style.display = dev ? '' : 'none';
    if(hideBtn) hideBtn.style.display = dev ? '' : 'none';

    // Guardar alimento: solo dev
    const saveBtn = $('saveFood');
    if(saveBtn) saveBtn.disabled = !dev;
  };

  const promptDevUnlock = ()=>{
    const pin = prompt('Modo desarrollador\n\nIntroduce PIN:');
    if(pin===null) return;
    if(String(pin).trim() === DEV_PIN){
      setDev(true);
      alert('Modo desarrollador ACTIVADO.');
      renderAll();
    } else {
      alert('PIN incorrecto.');
    }
  };

  const lockDev = ()=>{
    if(confirm('¬øDesactivar modo desarrollador?')){
      setDev(false);
      alert('Modo desarrollador DESACTIVADO.');
      renderAll();
    }
  };

  const bindDevLongPress = ()=>{
    const t = $('drawerTitle');
    if(!t) return;
    let timer=null;
    const start = ()=>{
      clearTimeout(timer);
      timer = setTimeout(()=>{
        // toggle con seguridad
        if(isDev()) lockDev();
        else promptDevUnlock();
      }, 1200);
    };
    const cancel = ()=>{ clearTimeout(timer); timer=null; };

    t.addEventListener('touchstart', start, {passive:true});
    t.addEventListener('touchend', cancel);
    t.addEventListener('touchcancel', cancel);
    t.addEventListener('mousedown', start);
    t.addEventListener('mouseup', cancel);
    t.addEventListener('mouseleave', cancel);
  };
  // ======= DEV OCR: UI wiring (r48) =======
  // Added button in DEV tools: #ocrScanBtn
  // Modal: #ocrBack (Esc√°ner nutricional)
  const bindDevOCR = ()=>{
    const btn = $('ocrScanBtn');
    if(!btn) return;

    const back = $('ocrBack');
    const closeBtn = $('ocrClose');
    const cancelBtn = $('ocrCancel');
    const pickBtn = $('ocrPickBtn');
    const fileIn = $('ocrFile');

    const nameIn = $('ocrName');
    const fatIn = $('ocrFat');
    const proIn = $('ocrProtein');
    const carbIn = $('ocrCarbs');
    const kcalIn = $('ocrKcal');
    const txt = $('ocrText');
    const confPill = $('ocrConf');
    const preview = $('ocrPreview');
    const warn = $('ocrWarn');

    let lastOCR = { text:'', confidence:null, per100:null, per100Detected:false };

    const show = ()=>{ if(back){ back.style.display='flex'; back.setAttribute('aria-hidden','false'); } };
    const hide = ()=>{
      if(back){ back.style.display='none'; back.setAttribute('aria-hidden','true'); }
      // reset file to allow re-pick
      if(fileIn) fileIn.value='';
    };

    const setWarn = (msg)=>{ if(!warn) return; warn.style.display = msg ? '' : 'none'; warn.textContent = msg || ''; };
    const setPreview = (obj)=>{
      if(!preview) return;
      if(!obj){ preview.style.display='none'; preview.textContent=''; return; }
      const est = obj.kcalEstimated ? ' (estimada)' : '';
      let s = `Por 100 g: G ${obj.fat} / P ${obj.protein} / C ${obj.carbs} / kcal ${obj.kcal}${est}`;
      if(obj.serving && obj.serving.grams){
        const sg = obj.serving.grams;
        const sf = (obj.serving.fat!=null) ? obj.serving.fat : '‚Äî';
        const sp = (obj.serving.protein!=null) ? obj.serving.protein : '‚Äî';
        const sc = (obj.serving.carbs!=null) ? obj.serving.carbs : '‚Äî';
        const sk = (obj.serving.kcal!=null) ? obj.serving.kcal : '‚Äî';
        s += ` ¬∑ Raci√≥n ${sg} g: G ${sf} / P ${sp} / C ${sc} / kcal ${sk}`;
      }
      preview.style.display='';
      preview.textContent = s;
    };;

    const readInputs = ()=>{
      const fat = clampNum(parseNumLoose(fatIn?.value), 0, 100);
      const protein = clampNum(parseNumLoose(proIn?.value), 0, 100);
      const carbs = clampNum(parseNumLoose(carbIn?.value), 0, 100);
      let kcal = parseNumLoose(kcalIn?.value);
      kcal = (kcal===null) ? null : clampNum(kcal, 0, 900);
      const ok = (fat!==null && protein!==null && carbs!==null);
      if(!ok) return null;

      let kcalEstimated = false;
      if(kcal===null){
        kcal = Math.round(fat*9 + (protein+carbs)*4);
        kcalEstimated = true;
      } else {
        kcal = Math.round(kcal);
      }
      return { fat, protein, carbs, kcal, kcalEstimated };
    };

    const refreshPreview = ()=>{
      const m = readInputs();
      if(!m){ setPreview(null); return; }
      setPreview(m);
    };

    [fatIn, proIn, carbIn, kcalIn].forEach(el=>{
      el?.addEventListener('input', refreshPreview);
    });

    async function runOCR(file){
      setWarn('');
      if(confPill){ confPill.style.display='inline-flex'; confPill.textContent='OCR‚Ä¶'; }
      try{
        const res = await sendImageToOCR(file);
        const text = res?.text || '';
        const per = res?.per100g || null;
        const conf = (typeof res?.confidence === 'number') ? res.confidence : null;

        lastOCR = { text, confidence: conf, per100: per, per100Detected:false };

        if(txt) txt.value = text;

        let parsed = null;
        if(per && typeof per === 'object'){
          parsed = {
            fat: parseNumLoose(per.fat),
            protein: parseNumLoose(per.protein),
            carbs: parseNumLoose(per.carbs),
            kcal: parseNumLoose(per.kcal)
          };
          lastOCR.per100Detected = true; // backend says per100g
        } else if(text){
          const loc = parseNutritionFromText(text);
          parsed = loc;
          lastOCR.per100Detected = !!loc.per100;
        }

        if(parsed){
          if(parsed.fat!==null && fatIn) fatIn.value = String(parsed.fat);
          if(parsed.protein!==null && proIn) proIn.value = String(parsed.protein);
          if(parsed.carbs!==null && carbIn) carbIn.value = String(parsed.carbs);
          if(parsed.kcal!==null && kcalIn) kcalIn.value = String(Math.round(parsed.kcal));
          refreshPreview();
        }

        if(confPill){
          confPill.style.display='inline-flex';
          confPill.textContent = (conf===null) ? 'OCR' : `OCR ${(conf*100).toFixed(0)}%`;
        }

        if(!lastOCR.per100Detected){
          setWarn('Aviso: no se detect√≥ claramente ‚Äúpor 100 g‚Äù. Revisa macros antes de guardar.');
        }

      }catch(err){
        if(confPill){ confPill.style.display='none'; }
        setWarn('Fallo OCR: ' + (err?.message || err));
      }
    }

    btn.addEventListener('click', ()=>{
      if(!isDev()){
        alert('Modo desarrollador BLOQUEADO.');
        return;
      }
      // reset UI
      if(confPill) confPill.style.display='none';
      setWarn('');
      if(txt) txt.value='';
      if(fatIn) fatIn.value='';
      if(proIn) proIn.value='';
      if(carbIn) carbIn.value='';
      if(kcalIn) kcalIn.value='';
      setPreview(null);
      show();
      setTimeout(()=>nameIn?.focus(), 50);
    });

    closeBtn?.addEventListener('click', hide);
    cancelBtn?.addEventListener('click', hide);
    back?.addEventListener('click', (e)=>{ if(e.target===back) hide(); });

    pickBtn?.addEventListener('click', ()=> fileIn?.click());
    fileIn?.addEventListener('change', ()=>{
      const f = fileIn.files && fileIn.files[0];
      if(!f) return;
      runOCR(f);
    });

    $('ocrSave')?.addEventListener('click', ()=>{
      if(!isDev()){
        alert('Modo desarrollador BLOQUEADO.');
        return;
      }
      const name = String(nameIn?.value||'').trim();
      if(!name){
        alert('Falta el nombre del producto.');
        return;
      }
      const m = readInputs();
      if(!m){
        alert('No se detectaron macros v√°lidos. Revisa Grasas/Prote√≠nas/Carbohidratos.');
        return;
      }

      // Build food object (per 100g). NO ml. NO modo unit aqu√≠.
      const id = slugSafe(name);

      // tags m√≠nimos (mejorable despu√©s con rules engine)
      const tags = [];
      if(m.protein >= 10) tags.push('protein');
      if(m.carbs >= 10) tags.push('carb');
      if(m.fat >= 10) tags.push('fat');
      // tags de uso: mantener estilo actual sin inventar estructuras
      tags.push('comida_ok'); // gen√©rico

      const foodObj = normalizeFood({
        id,
        name,
        baseUnit: '100g',
        kcal: m.kcal,
        p: m.protein,
        c: m.carbs,
        f: m.fat,
        unitGrams: null,
        tags
      });

      try{
        upsertFoodFromApp(foodObj);
        // refrescar UI foods drawer si est√° abierto
        renderAll();
        alert(`Guardado: ${foodObj.name}\n\n${preview?.textContent || ''}`);
        hide();
      }catch(err){
        alert('Error al guardar: ' + (err?.message || err));
      }
    });
  };



  // Barra de estado en A√±adir (kcal + macros)e en pantallas principales.
  const updateAddStatusBar = (goal,eaten)=>{
    try{
      const wrap=$('addStatusBar');
      if(!wrap || !goal || !eaten) return;
      const tab = (typeof state!=='undefined' && state && state.tab) ? state.tab : 'day';
      // Solo en pantalla A√±adir
      wrap.style.display = (tab==='add') ? 'block' : 'none';

      const remK = Math.round((goal.goalKcal||0) - (eaten.kcal||0));
      const remP = Math.round((goal.p||0) - (eaten.p||0));
      const remC = Math.round((goal.c||0) - (eaten.c||0));
      const remF = Math.round((goal.f||0) - (eaten.f||0));

      const kEl=$('addRemK'), pEl=$('addRemP'), cEl=$('addRemC'), fEl=$('addRemF');
      if(kEl) kEl.textContent = `${remK>=0?remK:('-'+Math.abs(remK))}`;
      if(pEl) pEl.textContent = `${remP>=0?('+'+remP):('-'+Math.abs(remP))}`;
      if(cEl) cEl.textContent = `${remC>=0?('+'+remC):('-'+Math.abs(remC))}`;
      if(fEl) fEl.textContent = `${remF>=0?('+'+remF):('-'+Math.abs(remF))}`;
    }catch(e){}
  };

  const round=(n,d=0)=>{const p=10**d; return Math.round((Number(n)||0)*p)/p;};
  const todayKey=()=>{
    const d=new Date();
    return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
  };

  // =========================
  // ACTIVE DAY + ROLLING 7-DAY WINDOW (hoy + 6)
  // =========================
  let activeDayKey = todayKey();

  const addDays = (dateObj, n)=>{
    const d=new Date(dateObj);
    d.setDate(d.getDate()+n);
    return d;
  };

  const dayLetterES = (dateObj)=>{
    // getDay(): 0=Dom..6=S√°b
    const map = ['D','L','M','X','J','V','S'];
    return map[dateObj.getDay()];
  };

  const dateKeyFromDateObj=(d)=>`${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;

  const getRollingWindowKeys = ()=>{
    const base = new Date();
    const out=[];
    for(let i=0;i<7;i++){
      const d = addDays(base, i);
      out.push({
        key: dateKeyFromDateObj(d),
        label: dayLetterES(d),
        offset: i
      });
    }
    return out;
  };

  const renderWeekChips = ()=>{
    const wrap = $('weekChips');
    if(!wrap) return;
    wrap.innerHTML='';
    const win = getRollingWindowKeys();

    // Siempre arrancamos en hoy si el activo ya qued√≥ atr√°s
    if(activeDayKey < todayKey()) activeDayKey = todayKey();

    win.forEach((d)=>{
      // Pre-crea settings/log del d√≠a futuro para que sea editable sin errores
      const storedMode = loadMode();
      ensureDaySettings(d.key, storedMode.modeKey);
      const logsAll = loadJSON(LS.logs, {});
      if(!logsAll[d.key]){ logsAll[d.key]=[]; saveJSON(LS.logs, logsAll); }

      const b=document.createElement('button');
      b.type='button';
      const dayNum = new Date(d.key+'T00:00:00').getDate();
      b.innerHTML = `<div>${d.label}</div><div style="font-size:11px;opacity:.65;">${dayNum}</div>`;
      b.className='miniBtn';
      if(d.key===activeDayKey){ b.classList.add('activeDay'); }
      b.title = d.key;
      b.onclick=()=>{ activeDayKey=d.key; renderAll(); };
      wrap.appendChild(b);
    });
  };

  const loadJSON=(k,fb)=>{try{const r=localStorage.getItem(k); return r?JSON.parse(r):fb;}catch{return fb;}};

  // =========================
  // RULES ENGINE (maridajes/caps) - configurable via JSON (DEV)
  // =========================
  const DEFAULT_RULES_ENGINE = {
    schemaVersion: 1,
    constraintsHard: {
      kcalToleranceBlock: 80,
      kcalToleranceDay: 100,
      proteinPerBlock: { min: 20, maxNormal: 45, maxPost: 50 },
      fatPerBlock: { min: 5, maxPre: 15, maxPost: 20, maxNeutral: 25 },
      carbPerBlock: { min: 0, maxPre: 90, maxPost: 120, maxNeutral: 140 },
      maxItemsPerBlock: 3,
      prefer2ItemsPerBlock: true
    },
    policy: {
      energyIsKing: true,
      proteinPriority: true,
      carbsAroundTraining: true,
      carbsAreLever: true,
      fatIsFloorNotTarget: true
    },
    contexts: {
      PRE: { priorityOrder: ['P','C','F'], capsOverride: { fatMax: 15 } },
      POST: { priorityOrder: ['P','C','F'], capsOverride: { proteinMax: 50, fatMax: 20 } },
      NEUTRAL: { priorityOrder: ['P','F','C'], capsOverride: { fatMax: 25 } }
    }
  };

  const validateRulesEngine = (obj)=>{
    if(!obj || typeof obj!=='object' || Array.isArray(obj)) throw new Error('Rules Engine inv√°lido');
    const sv = Number(obj.schemaVersion);
    if(!Number.isFinite(sv) || sv < 1) throw new Error('schemaVersion inv√°lido');
    if(!obj.constraintsHard || typeof obj.constraintsHard!=='object') throw new Error('Falta constraintsHard');
    if(!obj.contexts || typeof obj.contexts!=='object') throw new Error('Falta contexts');
    return obj;
  };

  const loadRulesEngine = ()=>{
    const r = loadJSON(LS.rulesEngine, null);
    if(!r) return DEFAULT_RULES_ENGINE;
    try{ return validateRulesEngine(r); }catch(_){ return DEFAULT_RULES_ENGINE; }
  };

  // Backup r√°pido (anti-p√©rdida al actualizar / recargar)
  const BACKUP_LAST_KEY = 'mc_backup_last';
  const snapshotState = ()=>{
    // No incluimos foodsRoot (viene del c√≥digo / json). Solo datos de usuario.
    return {
      ts: Date.now(),
      dataVersion: DATA_VERSION,
      mode: loadJSON(LS.mode, null),
      settings: loadJSON(LS.settings, null),
      logs: loadJSON(LS.logs, null),
      lastDate: loadJSON(LS.lastDate, null),
      profile: loadJSON(LS.profile, null),
      rulesEngine: loadJSON(LS.rulesEngine, null),
      foodsUser: loadJSON(LS.foodsUser, null),
      foodsHidden: loadJSON(DEV_HIDDEN_KEY, null),
      devMode: localStorage.getItem(DEV_MODE_KEY) || '0'
    };
  };

  const saveBackupLast = ()=>{
    try{ localStorage.setItem(BACKUP_LAST_KEY, JSON.stringify(snapshotState())); }catch(_){}
  };

  const saveJSON=(k,o)=>{
    localStorage.setItem(k,JSON.stringify(o));
    if(k===LS.mode || k===LS.settings || k===LS.logs || k===LS.lastDate || k===LS.profile || k===LS.foodsUser || k===LS.rulesEngine || k===DEV_HIDDEN_KEY){
      saveBackupLast();
    }
  };
  const getLevel=(mk,lk)=>(LEVELS[mk]||[]).find(x=>x.key===lk) || (LEVELS[mk]||[])[0];
  const daysSince = (ts)=>{
    if(!ts) return 9999;
    const diff = Date.now() - ts;
    return Math.floor(diff / (1000*60*60*24));
  };

  const normalizeFood = (f)=>({
    id: String(f.id||'').trim(),
    name: String(f.name||'').trim(),
    baseUnit: (f.baseUnit==='unit'?'unit':'100g'),
    kcal: Number(f.kcal)||0,
    p: Number(f.p)||0,
    c: Number(f.c)||0,
    f: Number(f.f)||0,
    unitGrams: (f.unitGrams===null || f.unitGrams===undefined || f.unitGrams==='') ? null : Number(f.unitGrams),
    tags: Array.isArray(f.tags) ? f.tags.map(x=>String(x).trim()).filter(Boolean) : String(f.tags||'').split(',').map(x=>x.trim()).filter(Boolean)
  });

  const uniqByIdPreferLast = (arr)=>{
    const m=new Map();
    arr.forEach(x=>{ if(x?.id) m.set(x.id, x); });
    return Array.from(m.values());
  };

  const qtyDisplay = (qtyType, qty)=>{
    const u = qtyType==='unit'?'u':(qtyType==='ml'?'ml':'g');
    return `${qty}${u}`;
  };

  // ======= PERFIL =======
  const defaultProfile = ()=>({ sex:'m', age:35, heightCm:175, weightKg:69, lastWeightUpdateTs:0 });

  const loadProfile = ()=>{
    const p=loadJSON(LS.profile,null);
    const base = p && typeof p==='object' ? p : defaultProfile();
    return {
      sex: (base.sex==='f')?'f':'m',
      age: Math.max(10, Number(base.age)||35),
      heightCm: Math.max(120, Number(base.heightCm)||175),
      weightKg: Math.max(30, Number(base.weightKg)||69),
      lastWeightUpdateTs: Number(base.lastWeightUpdateTs)||0
    };
  };

  const saveProfile = (p)=>saveJSON(LS.profile,p);

  // ======= FOODS =======
  const ensureFoodsStores = ()=>{
    const rootExists = !!localStorage.getItem(LS.foodsRoot);
    const userExists = !!localStorage.getItem(LS.foodsUser);
    const legacy = loadJSON(LS.foodsLegacy, null);

    if(!rootExists && !userExists && Array.isArray(legacy) && legacy.length){
      saveJSON(LS.foodsRoot, DEFAULT_FOODS.map(normalizeFood));
      saveJSON(LS.foodsUser, uniqByIdPreferLast(legacy.map(normalizeFood)));
      return;
    }
    if(!rootExists) saveJSON(LS.foodsRoot, DEFAULT_FOODS.map(normalizeFood));
    if(!userExists) saveJSON(LS.foodsUser, []);
    syncRootWithDefaults();
  };

  const syncRootWithDefaults = ()=>{
    const root = loadJSON(LS.foodsRoot, []);
    const rootMap = new Map((Array.isArray(root)?root:[]).map(f=>[f.id, normalizeFood(f)]));
    for(const d of DEFAULT_FOODS.map(normalizeFood)){
      if(!rootMap.has(d.id)) rootMap.set(d.id, d);
    }
    saveJSON(LS.foodsRoot, Array.from(rootMap.values()));
  };

  const loadFoodsMerged = (opts={})=>{
    ensureFoodsStores();
    const root = loadJSON(LS.foodsRoot, []).map(normalizeFood);
    const user = loadJSON(LS.foodsUser, []).map(normalizeFood);

    // sanea tags comunes (pos_ok -> post_ok), sin tocar IDs
    user.forEach(f=>{
      f.tags = (f.tags||[]).map(t=>t==='pos_ok'?'post_ok':t);
    });

    const map=new Map();
    root.forEach(f=>map.set(f.id,f));
    user.forEach(f=>map.set(f.id,f));
    const merged = Array.from(map.values());
    const includeHidden = !!opts.includeHidden;
    if(includeHidden) return merged;
    const hidden = new Set(loadHiddenIds());
    return merged.filter(f=>!hidden.has(f.id));
  };

  const upsertFoodFromApp = (foodObj)=>{
    ensureFoodsStores();
    const u = loadJSON(LS.foodsUser, []).map(normalizeFood);
    const idx = u.findIndex(x=>x.id===foodObj.id);
    if(idx>=0) u[idx]=foodObj; else u.push(foodObj);
    saveJSON(LS.foodsUser, uniqByIdPreferLast(u));
  };

  const foodById=(foods,id)=>foods.find(f=>f.id===id);

  // ======= DEV OCR: helpers (r48) =======
  function slugSafe(str){
    str = String(str||"").trim().toLowerCase();
    // quitar tildes
    str = str.normalize('NFD').replace(/[\u0300-\u036f]/g,'');
    // espacios y s√≠mbolos -> _
    str = str.replace(/[^a-z0-9]+/g,'_').replace(/_+/g,'_').replace(/^_+|_+$/g,'');
    return str || 'food';
  }

  function parseNumLoose(x){
    if(x===null || x===undefined) return null;
    const s = String(x).trim().replace(',', '.');
    const n = Number(s);
    return Number.isFinite(n) ? n : null;
  }

  function clampNum(n, lo, hi){
    n = Number(n);
    if(!Number.isFinite(n)) return null;
    return Math.max(lo, Math.min(hi, n));
  }

  // Local OCR parser fallback (ES/EN). Supports comma decimals.
  function parseNutritionFromText(text){
    // r51: Delegate to enhanced parser (supports 100g header, per-unit conversion, dual-column serving)
    const parsed = (typeof parseNutritionTextEnhanced === 'function') ? parseNutritionTextEnhanced(String(text||'')) : null;
    if(!parsed) return null;

    const fat = (parsed.fat!=null) ? +(+parsed.fat).toFixed(2) : null;
    const protein = (parsed.protein!=null) ? +(+parsed.protein).toFixed(2) : null;
    const carbs = (parsed.carbs!=null) ? +(+parsed.carbs).toFixed(2) : null;
    const kcal = (parsed.kcal!=null) ? Math.round(parsed.kcal) : null;

    const per100 = !!(parsed._baseInfo && parsed._baseInfo.per100g);
    const baseInfo = parsed._baseInfo || null;

    // Serving info (if label provides it). If grams exist but macro values missing, compute from per100.
    let serving = parsed._serving || null;
    if(serving && serving.grams && (serving.fat==null || serving.protein==null || serving.carbs==null || serving.kcal==null)){
      const factor = serving.grams / 100;
      serving = {
        grams: serving.grams,
        fat: (serving.fat!=null) ? serving.fat : (fat!=null ? +(fat*factor).toFixed(2) : null),
        protein: (serving.protein!=null) ? serving.protein : (protein!=null ? +(protein*factor).toFixed(2) : null),
        carbs: (serving.carbs!=null) ? serving.carbs : (carbs!=null ? +(carbs*factor).toFixed(2) : null),
        kcal: (serving.kcal!=null) ? Math.round(serving.kcal) : (kcal!=null ? Math.round(kcal*factor) : null)
      };
    }

    return {
      fat, protein, carbs, kcal,
      per100,
      serving,
      baseInfo,
      kcalEstimated: !!parsed._kcalEstimated,
      convertedFromUnit: !!parsed._convertedFromUnit
    };
  }

  async function sendImageToOCR(file){
    if(!OCR_ENDPOINT){
      throw new Error("OCR_ENDPOINT no est√° configurado.");
    }
    const fd = new FormData();

    // ===== r49 OCR.space compatibility =====
    // OCR.space expects:
    // - multipart field: "file"
    // - api key field: "apikey"
    // Docs: https://ocr.space/ocrapi
    if(/api\.ocr\.space\/parse\/image/i.test(OCR_ENDPOINT)){
      fd.append("file", file, file.name || "label.jpg");
      fd.append("apikey", (typeof OCR_SPACE_APIKEY==='string' ? OCR_SPACE_APIKEY.trim() : ""));
      fd.append("language", "spa");
      fd.append("isOverlayRequired", "false");
      fd.append("OCREngine", "2");
    } else {
      // Generic backend format (your own endpoint): expects multipart field "image"
      fd.append("image", file, file.name || "label.jpg");
    }

    const res = await fetch(OCR_ENDPOINT, { method:"POST", body: fd });
    if(!res.ok){
      const msg = await res.text().catch(()=> "");
      throw new Error("OCR HTTP " + res.status + (msg ? (": " + msg.slice(0,180)) : ""));
    }
    const json = await res.json();
    return json;
  }


  const macroFor=(food,qtyType,qty)=>{
    qty=Number(qty)||0; if(qty<=0) return {kcal:0,p:0,c:0,f:0};
    let factor=0;

    if(food.baseUnit==='100g'){
      const grams = qtyType==='g' ? qty : (qtyType==='unit' && food.unitGrams ? qty*food.unitGrams : qty);
      factor = grams/100;
    } else if(food.baseUnit==='100ml'){
      const ml = qtyType==='ml' ? qty : qty;
      factor = ml/100;
    } else {
      const units = qtyType==='unit' ? qty : qty;
      factor = units;
    }
    return {kcal:round(food.kcal*factor), p:round(food.p*factor,1), c:round(food.c*factor,1), f:round(food.f*factor,1)};
  };

  // ======= ETAPA =======
  const loadMode=()=>{
    const m=loadJSON(LS.mode,null);
    const def={modeKey:'deficit',levelKey:'d250',lastModeUpdateTs:0};
    if(m && m.modeKey && m.levelKey){
      return {
        modeKey: m.modeKey,
        levelKey: m.levelKey,
        lastModeUpdateTs: Number(m.lastModeUpdateTs)||0
      };
    }
    saveJSON(LS.mode,def);
    return def;
  };

  let modeDraft = null;

  const saveModeLevelOnly = (newLevelKey)=>{
    const cur = loadMode();
    const next = { ...cur, levelKey: newLevelKey };
    saveJSON(LS.mode, next);
  };

  const saveModeFull = (newModeKey, newLevelKey)=>{
    const next = { modeKey:newModeKey, levelKey:newLevelKey, lastModeUpdateTs: Date.now() };
    saveJSON(LS.mode, next);
  };

  // ======= D√çA =======
  const defaultNeatByMode = (modeKey)=> (modeKey==='surplus') ? 'med' : 'high';

  const ensureDaySettings=(dateKey, modeKey)=>{
    const all=loadJSON(LS.settings,{});
    if(!all[dateKey]){
      all[dateKey]={
        trainTime:'',
        wod:350,
        cardioKcal:'',
        steps:'',
        neatLevel: defaultNeatByMode(modeKey),
        panicOn: false
      };
      saveJSON(LS.settings,all);
    } else {
      if(all[dateKey].neatLevel===undefined) all[dateKey].neatLevel = defaultNeatByMode(modeKey);
      if(all[dateKey].steps===undefined) all[dateKey].steps = '';
      if(all[dateKey].panicOn===undefined) all[dateKey].panicOn = false;
      saveJSON(LS.settings,all);
    }
    return all[dateKey];
  };

  const loadDaySettings=(dateKey, modeKey)=>{
    const k=dateKey || todayKey();
    const day=ensureDaySettings(k, modeKey);
    return {k,day};
  };

  const saveDaySettings=(dateKey, day)=>{
    const k=dateKey || todayKey();
    const all=loadJSON(LS.settings,{});
    all[k]=day;
    saveJSON(LS.settings,all);
  };

  const loadLogs=(dateKey)=>{
    const k=dateKey || todayKey();
    const logs=loadJSON(LS.logs,{});
    if(!logs[k]){ logs[k]=[]; saveJSON(LS.logs,logs); }
    return {k,items:logs[k]};
  };

  
  // =========================
  // LEARNING (auto-aprendizaje)
  // Aprende combinaciones reales (pairings) cuando t√∫ registras comidas manualmente.
  // Guarda scores en localStorage bajo rules.learning.storeKey (default: mc_pairing_scores)
  const mcLearningKey=()=>{
    const r=loadRulesEngine?.();
    return (r?.learning?.storeKey) || 'mc_pairing_scores';
  };

  const mcLoadPairScores=()=> loadJSON(mcLearningKey(), {});
  const mcSavePairScores=(obj)=> saveJSON(mcLearningKey(), obj);

  const mcPairKey=(a,b)=>{
    if(!a||!b) return null;
    const x=String(a), y=String(b);
    return (x<y) ? (x+'|'+y) : (y+'|'+x);
  };

  const mcLearnFromLogs = (items)=>{
    if(!Array.isArray(items) || !items.length) return;
    const rules = loadRulesEngine?.();
    const inc = Number(rules?.learning?.increment ?? 1) || 1;

    // Agrupa por meal y aprende co-ocurrencias dentro del mismo bloque
    const byMeal = {};
    for(const it of items){
      const meal = normalizeMealLabel(it.meal);
      if(!meal) continue;
      (byMeal[meal] ||= []).push(it);
    }

    const store = mcLoadPairScores();

    for(const meal of Object.keys(byMeal)){
      const ids = Array.from(new Set(byMeal[meal].map(x=>x.foodId).filter(Boolean)));
      if(ids.length < 2) continue;

      // actualiza todos los pares (comida humana real)
      for(let i=0;i<ids.length;i++){
        for(let j=i+1;j<ids.length;j++){
          const k = mcPairKey(ids[i], ids[j]);
          if(!k) continue;
          store[k] = (Number(store[k]) || 0) + inc;
        }
      }
    }

    mcSavePairScores(store);
  };

  const mcGetPairScore=(a,b)=>{
    const k = mcPairKey(a,b);
    if(!k) return 0;
    const s = mcLoadPairScores();
    return Number(s[k]) || 0;
  };

  // =========================
  // TRACE (auditor√≠a Cuadrar D√≠a)
  const mcSaveLastPlanTrace = (trace)=>{
    try{ saveJSON('mc_last_plan_trace', trace); }catch(e){}
    try{ window.__mc_lastPlanTrace = trace; }catch(e){}
  };
  const mcLoadLastPlanTrace = ()=> loadJSON('mc_last_plan_trace', null);

const saveLogs=(dateKey, items)=>{
    const k=dateKey || todayKey();
    const logs=loadJSON(LS.logs,{});
    logs[k]=items;
    saveJSON(LS.logs,logs);
    // Auto-learning: aprende de tus combinaciones reales (manual o Cuadrar D√≠a)
    try{ mcLearnFromLogs(items); }catch(e){ /* no-op */ }
  };

  const sumMacros=(items)=>items.reduce((a,x)=>({kcal:a.kcal+x.kcal,p:a.p+x.p,c:a.c+x.c,f:a.f+x.f}),{kcal:0,p:0,c:0,f:0});

  // ======= BMR / GOAL =======
  const computeBMR = (profile)=>{
    const w=Number(profile.weightKg)||69;
    const h=Number(profile.heightCm)||175;
    const a=Number(profile.age)||35;
    const base = (10*w) + (6.25*h) - (5*a);
    return round(base + (profile.sex==='m'? 5 : -161));
  };

  const proteinTargetFromProfile = (profile)=> Math.round((Number(profile.weightKg)||69) * 2.5);

  const computeTDEE=(profile, day)=>{
    const bmr = computeBMR(profile);
    const neat = day.neatLevel || 'high';
    const pal = PAL[neat] || PAL.high;
    const base = bmr * pal;

    const wod = Number(day.wod)||0;

    const cardioKcal=Number(day.cardioKcal)||0;
    const cardioReal=cardioKcal*(1 - CARDIO_DISCOUNT); // 92%

    return round(base + wod + cardioReal);
  };

  const computeGoal=(profile, day, modeStored)=>{
    const tdee = computeTDEE(profile, day);
    const lvl = getLevel(modeStored.modeKey, modeStored.levelKey);

    let goalKcal = tdee + (lvl?.adj ?? 0);

    // P√ÅNICO (d√©ficit fijo de emergencia)
    if(day.panicOn){
      goalKcal -= (profile.sex==='m' ? 400 : 300);
    }

    const pTarget = proteinTargetFromProfile(profile);

    let fat = 62;
    if(modeStored.modeKey==='maint') fat=65;
    if(modeStored.modeKey==='surplus') fat=70;

    const carbKcal = Math.max(0, goalKcal - (pTarget*4) - (fat*9));
    const carbs = Math.floor(carbKcal/4);

    return {tdee, goalKcal:round(goalKcal), p:pTarget, c:carbs, f:fat};
  };

  // ======= CONTEXTO =======
  const timeContext=(trainTime)=>{
    if(!trainTime) return {ctx:'NEUTRA',detail:'Sin hora de entreno: reparto neutro.'};
    const now=new Date();
    const [hh,mm]=trainTime.split(':').map(Number);
    const t=new Date(now); t.setHours(hh,mm,0,0);
    const diffMin=Math.round((t-now)/60000);

    if(diffMin>=45 && diffMin<=180) return {ctx:'PRE',detail:`A ~${diffMin} min del entreno: hidrato alto, grasa baja.`};
    if(diffMin<45 && diffMin>=0) return {ctx:'PRE-R√ÅPIDO',detail:'A <45 min: hidrato f√°cil, casi sin grasa.'};

    const post=Math.abs(diffMin);
    if(diffMin<0 && post<=180) return {ctx:'POST',detail:`Post entreno (~${post} min): prote√≠na alta + hidrato.`};

    return {ctx:'NEUTRA',detail:'Fuera de ventana pre/post.'};
  };

  const mealFromClock = ()=>{
    const now = new Date();
    const h = now.getHours() + now.getMinutes()/60;
    if(h>=5 && h<10) return 'desayuno';
    if(h>=12 && h<15) return 'comida';
    if(h>=15 && h<18) return 'merienda';
    if(h>=18 && h<=22) return 'cena';
    return 'otros';
  };

  const normalizeMealLabel = (m)=>{
    if(m==='post') return 'post_entreno';
    if(m==='pre') return 'pre_entreno';
    return m;
  };

  const prettyMeal = (m)=>{
    m = normalizeMealLabel(m);
    if(m==='desayuno') return 'Desayuno';
    if(m==='comida') return 'Comida';
    if(m==='merienda') return 'Merienda';
    if(m==='cena') return 'Cena';
    if(m==='post_entreno') return 'Post-entreno';
    if(m==='pre_entreno') return 'Pre-entreno';
    return 'Otros';
  };

  const mealOrder = (m)=>{
    m = normalizeMealLabel(m);
    if(m==='desayuno') return 1;
    if(m==='comida') return 2;
    if(m==='merienda') return 3;
    if(m==='cena') return 4;
    if(m==='post_entreno') return 5;
    if(m==='pre_entreno') return 6;
    return 9;
  };

  const slotToAllowedTag = (slot)=>(
    (slot==='desayuno') ? 'desayuno_ok' :
    (slot==='comida') ? 'comida_ok' :
    (slot==='merienda') ? 'merienda_ok' :
    (slot==='cena') ? 'cena_ok' :
    (slot==='post_entreno') ? 'post_ok' :
    (slot==='pre_entreno') ? 'pre_ok' :
    null
  );

  // ======= RECOMENDADOR =======
  const shuffled = (arr)=>{
    const a=arr.slice();
    for(let i=a.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [a[i],a[j]]=[a[j],a[i]];
    }
    return a;
  };

  const recommendForSlot=(foods,goal,eaten,ctx,slotOverride, randomize=false)=>{
    const rem={
      kcal:Math.max(0,goal.goalKcal-eaten.kcal),
      p:Math.max(0,goal.p-eaten.p),
      c:Math.max(0,goal.c-eaten.c),
      f:Math.max(0,goal.f-eaten.f)
    };

    const allowedTag = slotToAllowedTag(slotOverride);
    const allow = (f)=> !allowedTag || (f.tags||[]).includes(allowedTag);

    let tgt;
    if(ctx==='PRE') tgt={p:Math.min(30,rem.p), c:Math.min(110,rem.c), f:Math.min(12,rem.f), kcal:Math.min(650,rem.kcal)};
    else if(ctx==='PRE-R√ÅPIDO') tgt={p:Math.min(20,rem.p), c:Math.min(60,rem.c), f:Math.min(8,rem.f), kcal:Math.min(350,rem.kcal)};
    else if(ctx==='POST') tgt={p:Math.min(65,rem.p), c:Math.min(140,rem.c), f:Math.min(20,rem.f), kcal:Math.min(900,rem.kcal)};
    else tgt={p:Math.min(60,rem.p), c:Math.min(90,rem.c), f:Math.min(22,rem.f), kcal:Math.min(800,rem.kcal)};

    if(slotOverride==='desayuno' || slotOverride==='merienda') tgt.f = Math.min(tgt.f, 16);

    let proteins=foods.filter(f=>f.tags?.includes('protein') && allow(f));
    let carbs=foods.filter(f=>f.tags?.includes('carb') && allow(f));
    let fruits=foods.filter(f=>['banana','freson','uva'].includes(f.id) && allow(f));

    if(!proteins.length) return null;

    const protPref=['queso_batido_0','claras','huevo_M','pollo_pechuga'];
    proteins.sort((a,b)=>protPref.indexOf(a.id)-protPref.indexOf(b.id));

    const protGr=[150,200,250,300];
    const carbGr=[120,150,180,200,220,250,300];
    const fruitGr=[100,120,150,180];

    const protIter = randomize ? shuffled(proteins) : proteins;
    const protGrIter = randomize ? shuffled(protGr) : protGr;
    const carbGrIter = randomize ? shuffled(carbGr) : carbGr;
    const fruitGrIter = randomize ? shuffled(fruitGr) : fruitGr;

    let best=null;

    const score=(tot)=>{
      const dp=Math.max(0,tgt.p-tot.p);
      const df=Math.max(0,tgt.f-tot.f);
      const dc=Math.max(0,tgt.c-tot.c);

      const overKcal = tot.kcal>rem.kcal ? (tot.kcal-rem.kcal)*1.0 : 0;
      const fatHard = ((ctx.startsWith('PRE') || slotOverride==='desayuno' || slotOverride==='merienda') && tot.f>18) ? (tot.f-18)*10 : 0;

      const jitter = randomize ? (Math.random()*0.35) : 0;
      return dp*10 + df*4 + dc*1.5 + overKcal + fatHard + jitter;
    };

    for(const pr of protIter){
      for(const pg of (pr.baseUnit==='unit'?[1,2]:protGrIter)){
        const prQtyType=(pr.baseUnit==='unit'?'unit':'g');
        const prM=macroFor(pr,prQtyType,pg);

        const carbPool = (tgt.c>20 && carbs.length) ? (randomize?shuffled(carbs):carbs) : [null];
        for(const cb of carbPool){
          for(const cg of (cb?(cb.baseUnit==='unit'?[1,2]:carbGrIter):[0])){
            const cbQtyType = cb ? (cb.baseUnit==='unit'?'unit':'g') : 'g';
            const cbM=cb?macroFor(cb,cbQtyType,cg):{kcal:0,p:0,c:0,f:0};

            const needFruit = (tgt.c - (prM.c+cbM.c) > 25) && fruits.length;
            const fruitPool = needFruit ? (randomize?shuffled(fruits):fruits) : [null];

            for(const fr of fruitPool){
              for(const fg of (fr?fruitGrIter:[0])){
                const frM=fr?macroFor(fr,'g',fg):{kcal:0,p:0,c:0,f:0};

                const tot={
                  kcal:prM.kcal+cbM.kcal+frM.kcal,
                  p:prM.p+cbM.p+frM.p,
                  c:prM.c+cbM.c+frM.c,
                  f:prM.f+cbM.f+frM.f
                };

                const s=score(tot);
                if(!best || s<best.s){
                  best={s, slot:slotOverride, ctx, items:[
                    {meal:slotOverride, foodId:pr.id,name:pr.name, qtyType:prQtyType, qty:pg, qtyDisplay:qtyDisplay(prQtyType,pg), ...prM},
                    ...(cb?[{meal:slotOverride, foodId:cb.id,name:cb.name, qtyType:cbQtyType, qty:cg, qtyDisplay:qtyDisplay(cbQtyType,cg), ...cbM}]:[]),
                    ...(fr?[{meal:slotOverride, foodId:fr.id,name:fr.name, qtyType:'g', qty:fg, qtyDisplay:qtyDisplay('g',fg), ...frM}]:[])
                  ], tot};
                }
              }
            }
          }
        }
      }
    }
    return best;
  };

  // ======= MACROS OK =======
  // Objetivo: cuadrar SOLO lo que falta en el d√≠a, respetando lo ya registrado.
  // Post-entreno es opcional y solo entra si (WOD > 0) o (Calor√≠as activas > 0). NEAT NO afecta.
  const planMacrosOk=(foods, goal, logs, day)=>{
    const rules = loadRulesEngine();
    const hard = rules?.constraintsHard || DEFAULT_RULES_ENGINE.constraintsHard;
    const ctxConf = rules?.contexts || DEFAULT_RULES_ENGINE.contexts;

    const baseSlots = ['desayuno','comida','merienda','cena'];

    const postActive = ((Number(day?.wod)||0) > 0) || ((Number(day?.cardioKcal)||0) > 0);
    const allSlots = postActive ? [...baseSlots, 'post_entreno'] : [...baseSlots];

    const dateKey = activeDayKey || todayKey();

    const eaten = sumMacros(logs);

    // ===== trace (auditor√≠a) =====
    const __trace = {
      ts: Date.now(),
      goal: { kcal: goal.goalKcal, p: goal.p, c: goal.c, f: goal.f },
      eaten: { kcal: eaten.kcal, p: eaten.p, c: eaten.c, f: eaten.f },
      postActive: !!postActive,
      slotsToPlan: [],
      slots: {}, // por slot: ctx, caps, decisiones, items
      notes: []
    };


    // qu√© slots ya est√°n ‚Äúrellenos‚Äù (tienen al menos 1 item)
    const filled = new Set();
    for(const it of logs){
      const mk = normalizeMealLabel(it.meal);
      if(mk) filled.add(mk);
    }

    // slots a completar = los activos que NO est√©n rellenos
    let slotsToPlan = allSlots.filter(s => !filled.has(s));
    // Barajar slots (determinista por d√≠a) para no repetir siempre el mismo orden
    const __slotSeed = mcSeedFromString(String(dateKey||''));
    slotsToPlan = mcShuffleDet(slotsToPlan, __slotSeed);
    __trace.slotsToPlan = slotsToPlan.slice();

    // Caso especial: si no queda ning√∫n slot activo pero faltan kcal, permitir ‚Äúpre_entreno‚Äù
    // SOLO si ya existe cena (√∫ltima comida tradicional) y a√∫n falta por cuadrar.
    const remainingNow = ()=>{
      const e = sumMacros([...logs, ...plannedItems]); // plannedItems definido m√°s abajo
      return {
        kcal: Math.max(0, goal.goalKcal - e.kcal),
        p: Math.max(0, goal.p - e.p),
        c: Math.max(0, goal.c - e.c),
        f: Math.max(0, goal.f - e.f),
      };
    };

    // ===== variedad y anti-repetici√≥n (r51.1) =====
    // Evita que "Cuadrar D√≠a" repita siempre las mismas comidas en el mismo orden.
    // Estrategia:
    // - Baraja slots a planificar con semilla por d√≠a (determinista, no ca√≥tica).
    // - Penaliza alimentos usados en los √∫ltimos N d√≠as (recency penalty).
    // - Mantiene preferencia hist√≥rica, pero no secuestra la elecci√≥n.

    const mcSeedFromString = (s)=>{
      let h=2166136261;
      for(let i=0;i<s.length;i++){
        h ^= s.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return (h>>>0);
    };
    const mcMulberry32 = (a)=>()=>{
      let t = a += 0x6D2B79F5;
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
    const mcShuffleDet = (arr, seed)=>{
      const out = arr.slice();
      const rnd = mcMulberry32(seed||1);
      for(let i=out.length-1;i>0;i--){
        const j = Math.floor(rnd()*(i+1));
        [out[i], out[j]] = [out[j], out[i]];
      }
      return out;
    };
    const mcParseDateKey = (k)=>{
      const m = String(k||'').match(/^(\d{4})-(\d{2})-(\d{2})$/);
      if(!m) return null;
      return new Date(Number(m[1]), Number(m[2])-1, Number(m[3]));
    };
    const mcDateKeyOf = (d)=>{
      const y=d.getFullYear();
      const m=String(d.getMonth()+1).padStart(2,'0');
      const da=String(d.getDate()).padStart(2,'0');
      return `${y}-${m}-${da}`;
    };
    const mcGetPrevDateKeys = (dayKey, daysBack)=>{
      const base = mcParseDateKey(dayKey);
      if(!base) return [];
      const out=[];
      for(let i=1;i<=daysBack;i++){
        const d = new Date(base);
        d.setDate(d.getDate()-i);
        out.push(mcDateKeyOf(d));
      }
      return out;
    };

    const mcGetRecentFoodCounts = (dayKey, daysBack)=>{
      const all = loadJSON(LS.logs, {});
      const keys = mcGetPrevDateKeys(dayKey, daysBack);
      const counts = {};
      for(const k of keys){
        const items = all?.[k] || [];
        for(const it of items){
          const id = it?.foodId;
          if(!id) continue;
          counts[id] = (counts[id]||0) + 1;
        }
      }
      return counts;
    };

    // Penalizaci√≥n por recencia. 0 = no usado; 1..N = repetido recientemente.
    const __recentCounts = mcGetRecentFoodCounts(dateKey, 4);
    const mcRecentCount = (id)=> (__recentCounts?.[id] || 0);

    const mcVarietySort = (arr, tag, slot)=>{
      if(!Array.isArray(arr) || arr.length<=1) return arr;

      // semilla por d√≠a+slot+tag: determinista pero var√≠a entre d√≠as
      const seed = mcSeedFromString(String(dateKey||'')+'|'+String(slot||'')+'|'+String(tag||''));
      const rnd = mcMulberry32(seed);

      // Rank de preferencia (si ya se aplic√≥ preferOrder, esto solo es desempate)
      const prefRank = {};
      for(let i=0;i<arr.length;i++) prefRank[arr[i].id]=i;

      // Orden:
      // 1) Menos repetido en √∫ltimos d√≠as
      // 2) Mantener el orden de preferencia actual
      // 3) Desempate pseudo-aleatorio (sembrado)
      return arr.slice().sort((a,b)=>{
        const ra = mcRecentCount(a.id);
        const rb = mcRecentCount(b.id);
        if(ra !== rb) return ra - rb;
        const pa = prefRank[a.id] ?? 9999;
        const pb = prefRank[b.id] ?? 9999;
        if(pa !== pb) return pa - pb;
        return (rnd() - 0.5);
      });
    };

    // ===== helpers selecci√≥n =====
    const preferOrder = (arr, ids)=>{
      const m=new Map(arr.map(x=>[x.id,x]));
      const out=[];
      ids.forEach(id=>{ if(m.has(id)) out.push(m.get(id)); });
      for(const x of arr){ if(!ids.includes(x.id)) out.push(x); }
      return out;
    };

    const allowedForSlot = (slot)=>{
      const tag = slotToAllowedTag(slot);
      return (f)=> !tag || (f.tags||[]).includes(tag);
    };

    const candidatesByTag = (tag, slot)=>{
      const allow = allowedForSlot(slot);
      let arr = foods.filter(f => (f.tags||[]).includes(tag) && allow(f));
      if(tag==='fruit'){
        arr = foods.filter(f => ['banana','freson','uva','manzana'].includes(f.id) && allow(f));
      }
      if(tag==='protein'){
        arr = preferOrder(arr, ['queso_batido_0','claras','huevo_M','pollo_pechuga','Pechuga_92%_pavo_hacendado_lonchas','lomo_cerdo','Lomo_embuchado_Hacendado_lonchas']);
      }
      if(tag==='carb'){
        arr = preferOrder(arr, ['gnocchi','pan_cristal','Pan_Brioche_Hamburguesa_Hacendado','Pan_molde_blanco_Hacendado','patata_guarnicion','baston_batata']);
      }
      if(tag==='fat'){
        arr = preferOrder(arr, ['chocolate_85','crema_cacahuete','aceite_oliva','Bac√≥n_ahumado_La_Selva_lonchas','queso_lonchas_light']);
      }
      return mcVarietySort(arr, tag, slot);
    };

    // ===== aprendizaje: preferir combinaciones reales =====
    const scoringConf = (rules?.selection?.scoring) || { useLearnedScore:true, learnedWeight:0.55, baseWeight:0.45 };
    const useLearned = scoringConf.useLearnedScore !== false;
    const learnedW = Number(scoringConf.learnedWeight ?? 0.55);
    const learnedScale = 6; // escala pr√°ctica: evita aleatoriedad, sin dominar el motor

    const pickPartnerByLearning = (baseFoodId, pool)=>{
      if(!pool || !pool.length) return null;
      if(!useLearned || !baseFoodId) return pool[0];

      let best = pool[0];
      let bestS = -1;

      for(const f of pool){
        const s = mcGetPairScore(baseFoodId, f.id);
        if(s > bestS){
          bestS = s;
          best = f;
        }
      }
      return best;
    };

    const learnedBonusForIds = (ids)=>{
      if(!useLearned || !Array.isArray(ids)) return 0;
      let sum=0;
      for(let i=0;i<ids.length;i++){
        for(let j=i+1;j<ids.length;j++){
          sum += mcGetPairScore(ids[i], ids[j]);
        }
      }
      return sum;
    };

    const clamp = (v, lo, hi)=>Math.max(lo, Math.min(hi, v));
    const round5 = (x)=> Math.round(x/5)*5;

    const ctxForSlot = (slot)=>{
      if(slot==='post_entreno') return 'POST';
      if(slot==='pre_entreno') return 'PRE';
      return 'NEUTRAL';
    };

    const capsForCtx = (ctx)=>{
      const base = {
        pMin: Number(hard?.proteinPerBlock?.min ?? 20),
        pMax: Number((ctx==='POST') ? (hard?.proteinPerBlock?.maxPost ?? 50) : (hard?.proteinPerBlock?.maxNormal ?? 45)),
        fMin: Number(hard?.fatPerBlock?.min ?? 5),
        fMax: Number(ctx==='PRE' ? (hard?.fatPerBlock?.maxPre ?? 15) : (ctx==='POST' ? (hard?.fatPerBlock?.maxPost ?? 20) : (hard?.fatPerBlock?.maxNeutral ?? 25))),
        cMin: Number(hard?.carbPerBlock?.min ?? 0),
        cMax: Number(ctx==='PRE' ? (hard?.carbPerBlock?.maxPre ?? 90) : (ctx==='POST' ? (hard?.carbPerBlock?.maxPost ?? 120) : (hard?.carbPerBlock?.maxNeutral ?? 140))),
        maxItems: Number(hard?.maxItemsPerBlock ?? 3)
      };
      const ov = (ctxConf && ctxConf[ctx] && ctxConf[ctx].capsOverride) ? ctxConf[ctx].capsOverride : null;
      if(ov){
        if(Number.isFinite(Number(ov.proteinMax))) base.pMax = Number(ov.proteinMax);
        if(Number.isFinite(Number(ov.fatMax))) base.fMax = Number(ov.fatMax);
        if(Number.isFinite(Number(ov.carbMax))) base.cMax = Number(ov.carbMax);
      }
      return base;
    };

    const qtyForMacro = (food, macroKey, target)=>{
      // target en gramos de macro; devuelve qty (g o units) aproximada
      const per = macroFor(food, 'g', 100);
      const perUnit = macroFor(food, 'unit', 1);
      if(food.baseUnit==='unit'){
        const mv = (macroKey==='p'?perUnit.p:(macroKey==='c'?perUnit.c:perUnit.f));
        if(mv<=0) return 1;
        return clamp(Math.round(target / mv), 1, 6);
      } else {
        const mv = (macroKey==='p'?per.p:(macroKey==='c'?per.c:per.f));
        if(mv<=0) return 100;
        return clamp(round5((target / mv)*100), 30, 400);
      }
    };

    const addItem = (slot, food, qtyType, qty)=>{
      const mac = macroFor(food, qtyType, qty);
      plannedItems.push({
        meal: slot,
        foodId: food.id,
        name: food.name,
        qtyType,
        qty,
        qtyDisplay: qtyDisplay(qtyType, qty),
        kcal: mac.kcal, p: mac.p, c: mac.c, f: mac.f
      });
      try{
        const slotKey = normalizeMealLabel(slot);
        __trace.slots[slotKey] ||= { ctx: ctxForSlot(slotKey), caps: capsForCtx(ctxForSlot(slotKey)), decisions: {}, items: [] };
        __trace.slots[slotKey].items.push({ foodId: food.id, name: food.name, qtyType, qty, kcal: mac.kcal, p: mac.p, c: mac.c, f: mac.f });
      }catch(e){}
    };

    const buildSlot = (slot, rem, slotsLeft)=>{
      const ctx = ctxForSlot(slot);
      const caps = capsForCtx(ctx);
      // target kcal para este slot
      const kcalTarget = clamp(Math.round(rem.kcal / Math.max(1, slotsLeft)), 260, 900);

      const proteins = candidatesByTag('protein', slot);
      const carbs    = candidatesByTag('carb', slot);
      const fats     = candidatesByTag('fat', slot);
      const fruits   = candidatesByTag('fruit', slot);

      if(!proteins.length) return;


      // trace init para este slot
      try{
        __trace.slots[slot] ||= { ctx, caps, decisions: {}, items: [] };
        __trace.slots[slot].decisions.kcalTarget = kcalTarget;
        __trace.slots[slot].decisions.remBefore = { kcal: rem.kcal, p: rem.p, c: rem.c, f: rem.f };
        // Ranking aprendido (top 5) para partners
        const topLearn = (baseId, pool)=> (pool||[]).slice(0,6).map(x=>({id:x.id, s: mcGetPairScore(baseId,x.id)})).sort((a,b)=>b.s-a.s).slice(0,5);
        __trace.slots[slot].decisions.learned = {};
        __trace.slots[slot].decisions.learned.protein = proteins[0]?.id || null;
        __trace.slots[slot].decisions.learned.carbsTop = proteins[0] ? topLearn(proteins[0].id, carbs) : [];
        __trace.slots[slot].decisions.learned.fatsTop  = proteins[0] ? topLearn(proteins[0].id, fats) : [];
      }catch(e){}

      // 1) Prote√≠na base
      const pFood = proteins[0];
      // Prote√≠na por bloque: humana y capada (evita 60g)
      const pNeed = clamp(rem.p / Math.max(1, slotsLeft), Math.max(20, caps.pMin), caps.pMax);
      const pQty = qtyForMacro(pFood, 'p', pNeed);
      addItem(slot, pFood, (pFood.baseUnit==='unit'?'unit':'g'), pQty);

      // 2) Hidrato si hace falta o si faltan kcal
      let afterP = sumMacros(plannedItems.filter(x=>x.meal===slot));
      let localRem = { ...rem, kcal: Math.max(0, kcalTarget - afterP.kcal) };

      const needCarb = (rem.c / Math.max(1, slotsLeft)) > 18 || localRem.kcal > 220;
      if(needCarb){
        const cFood = pickPartnerByLearning(pFood.id, carbs) || pickPartnerByLearning(pFood.id, fruits);
        if(cFood){
          const cNeed = clamp(rem.c / Math.max(1, slotsLeft), 20, caps.cMax);
          const cQty = (cFood.id==='banana'||cFood.id==='uva'||cFood.id==='freson'||cFood.id==='manzana')
            ? clamp(round5(cNeed*5), 80, 250)
            : qtyForMacro(cFood, 'c', cNeed);
          // Si ya tenemos demasiados items, mejor subir qty de lo existente
          const existingCount = plannedItems.filter(x=>x.meal===slot).length;
          if(existingCount < caps.maxItems){
            addItem(slot, cFood, (cFood.baseUnit==='unit'?'unit':'g'), cQty);
          }
        }
      }

      // 3) Grasa/extra para cerrar kcal si sigue corto o falta grasa del d√≠a
      afterP = sumMacros(plannedItems.filter(x=>x.meal===slot));
      const needFat = (rem.f / Math.max(1, slotsLeft)) > 12 || (kcalTarget - afterP.kcal) > 180;

      if(needFat && fats.length){
        const fFood = pickPartnerByLearning(pFood.id, fats) || fats[0];
        // target grasa moderada
        const fNeed = clamp(rem.f / Math.max(1, slotsLeft), Math.max(6, caps.fMin), caps.fMax);
        const fQty = qtyForMacro(fFood, 'f', fNeed);
        const existingCount = plannedItems.filter(x=>x.meal===slot).length;
        if(existingCount < caps.maxItems){
          addItem(slot, fFood, (fFood.baseUnit==='unit'?'unit':'g'), fQty);
        }
      }


      // 3.5) Micro-ajuste: evitar residuales raros (ej. faltan ~60 kcal => 10g chocolate 85)
      const afterMain = sumMacros(plannedItems.filter(x=>x.meal===slot));
      const microKcal = kcalTarget - afterMain.kcal;
      if(microKcal >= 35 && microKcal <= 95){
        const microFood = foods.find(x=>x.id==='chocolate_85' && allowedForSlot(slot)(x));
        const existingCount2 = plannedItems.filter(x=>x.meal===slot).length;
        if(microFood && existingCount2 < caps.maxItems){
          const kcalPerG = (Number(microFood.kcal)||0) / 100;
          if(kcalPerG > 0){
            let g = Math.round((microKcal / kcalPerG) / 5) * 5;
            g = clamp(g, 5, 20);
            addItem(slot, microFood, 'g', g);
          }
        }
      }

      // 4) Ajuste final: si a√∫n falta mucha kcal, empuja con carb o fat seg√∫n lo que falte
      let guard=0;
      while(guard++<6){
        const slotTot = sumMacros(plannedItems.filter(x=>x.meal===slot));
        const delta = kcalTarget - slotTot.kcal;
        if(delta < 120) break;

        // decide si empujar con carb o fat
        // PRE/POST: empujar con carb es m√°s humano; NEUTRAL decide por lo que falte
        const wantCarb = (ctx==='PRE' || ctx==='POST') ? true : ((rem.c > rem.f*0.8) || carbs.length);
        const pushFood = wantCarb ? (carbs[0] || fruits[0]) : fats[0];
        if(!pushFood) break;

        const qtyType = (pushFood.baseUnit==='unit') ? 'unit' : 'g';
        const step = (qtyType==='unit') ? 1 : (pushFood.tags?.includes('fat') ? 10 : 50);

        // si ya existe ese alimento en slot, sube qty, si no, a√±√°delo
        const existing = plannedItems.find(x=>x.meal===slot && x.foodId===pushFood.id);
        if(existing){
          existing.qty += step;
          const mac = macroFor(pushFood, existing.qtyType, existing.qty);
          existing.qtyDisplay = qtyDisplay(existing.qtyType, existing.qty);
          existing.kcal=mac.kcal; existing.p=mac.p; existing.c=mac.c; existing.f=mac.f;
        } else {
          const existingCount = plannedItems.filter(x=>x.meal===slot).length;
          if(existingCount >= caps.maxItems) break;
          addItem(slot, pushFood, qtyType, (qtyType==='unit'?1:step));
        }
      }
    };

    const plannedItems = [];

    // Si el d√≠a est√° vac√≠o (no hay logs), cuadrar el d√≠a completo en slots base (+post si activo)
    // Si ya hay algo, solo completar slots restantes.
    // Si slotsToPlan qued√≥ vac√≠o pero falta, permitir pre_entreno si existe cena.
    const initialRem = {
      kcal: Math.max(0, goal.goalKcal - eaten.kcal),
      p: Math.max(0, goal.p - eaten.p),
      c: Math.max(0, goal.c - eaten.c),
      f: Math.max(0, goal.f - eaten.f),
    };

    // Si no hay nada y aun as√≠ rem muy bajo, no hacemos nada.
    if(initialRem.kcal < 120) return {slots:[], slotsToPlan:[], items:[], tot:{kcal:0,p:0,c:0,f:0}, context:'Nada que cuadrar.'};

    // Plan principal
    for(let i=0;i<slotsToPlan.length;i++){
      const slot = slotsToPlan[i];
      const rem = remainingNow();
      if(rem.kcal < 160) break;
      buildSlot(slot, rem, (slotsToPlan.length - i));
    }

    // Caso especial: si no quedan slotsToPlan (o ya los hemos llenado) y a√∫n falta bastante, permitir pre_entreno
    // SOLO si ya existe 'cena' en logs (√∫ltima comida) y el usuario no tiene post activo (o ya est√° relleno).
    const remAfter = remainingNow();
    if(remAfter.kcal > 220){
      const hasDinner = filled.has('cena');
      const postFilled = filled.has('post_entreno');
      const allowPre = hasDinner && (!postActive || postFilled);
      if(allowPre && !filled.has('pre_entreno')){
        // meter un bloque extra para cerrar (pre-entreno)
        buildSlot('pre_entreno', remAfter, 1);
        if(!allSlots.includes('pre_entreno')) allSlots.push('pre_entreno');
        if(!slotsToPlan.includes('pre_entreno')) slotsToPlan.push('pre_entreno');
      }
    }

    // Totales del plan
    const tot = plannedItems.reduce((a,x)=>({kcal:a.kcal+x.kcal,p:a.p+x.p,c:a.c+x.c,f:a.f+x.f}),{kcal:0,p:0,c:0,f:0});

    const plannedLabels = slotsToPlan.map(prettyMeal).join(' + ');
    const ctx = `Cuadrando: ${plannedLabels || '‚Äî'} ¬∑ Restan ${Math.round(Math.max(0, goal.goalKcal - (eaten.kcal+tot.kcal)))} kcal.`;
    mcSaveLastPlanTrace(__trace);
    return {slots: allSlots, slotsToPlan, items: plannedItems, tot, context: ctx};
  };
  // ======= ESTADO =======
  const computeDayStatus=(goal,eaten)=>{
    // Estado consistente con la filosof√≠a:
    // - Mandan las calor√≠as (d√©ficit). Si kcal est√°n en rango, el d√≠a "cuenta".
    // - Prote√≠na es prioridad. Si P est√° cubierta, el d√≠a puede ser BUENO aunque C/F est√©n desbalanceados.
    const gK = Number(goal.goalKcal)||0;
    const eK = Number(eaten.kcal)||0;
    const gP = Number(goal.p)||0;
    const eP = Number(eaten.p)||0;
    const gF = Number(goal.f)||0;
    const eF = Number(eaten.f)||0;
    const gC = Number(goal.c)||0;
    const eC = Number(eaten.c)||0;

    const tolKcal = Math.max(100, gK*0.03);
    const kcalDiff = eK - gK; // + pasado

    const w = Number(($('weight')&&$('weight').value)||0);
    const minPhysFat = w>0 ? (0.6*w) : 0;

    const proteinOk = (gP<=0) ? true : (eP >= (gP - 5));
    const fatPhysOk = (minPhysFat<=0) ? true : (eF >= (minPhysFat - 0.1));
    const energyOk = Math.abs(kcalDiff) <= tolKcal;

    // "Perfecto" exige que los 3 macros est√©n razonablemente cerca (tolerancias simples)
    const perfect = energyOk && proteinOk && fatPhysOk &&
      (Math.abs(eC - gC) <= 15) && (Math.abs(eF - gF) <= 5) && (Math.abs(eP - gP) <= 10);

    let state='ok';
    let label='REGULAR';

    if(!energyOk){
      state='bad';
      label='REVISAR';
    } else if(proteinOk && fatPhysOk){
      state='good';
      label = perfect ? 'PERFECTO' : 'BUENO';
    } else {
      state='ok';
      label='MEJORABLE';
    }

    const bits=[];
    const kcalSigned = `${(Math.round(kcalDiff)>0?'+':'')}${Math.round(kcalDiff)} kcal`;
    bits.push(energyOk ? 'Energ√≠a: OK' : `Energ√≠a: ${kcalSigned}`);
    if(!proteinOk) bits.push('Prote√≠na: baja');
    else bits.push('Prote√≠na: OK');
    if(!fatPhysOk) bits.push('Grasa: muy baja');

    // Macro balance (solo si energ√≠a OK)
    if(energyOk){
      const notes=[];
      if(eF < (gF - 6)) notes.push('F baja');
      if(eC > (gC + 20)) notes.push('C alta');
      if(notes.length) bits.push(`Macros: ${notes.join(' ¬∑ ')}`);
      else bits.push('Macros: OK');
    }

    const detail = bits.join(' ¬∑ ');
    return {state,label,detail};
  };

  const macroStatus = (modeKey, macroKey, eatenVal, goalVal) => {
    const eaten = Number(eatenVal) || 0;
    const goal = Number(goalVal) || 0;
    if(goal <= 0) return {state:'ok', label:'‚Äî', detail:''};

    const ratio = eaten / goal;

    let tol = {
      protein: { greenMin: 0.95, greenMax: 1.10, okMin: 0.90, okMax: 1.15 },
      carbs:   { greenMin: 0.90, greenMax: 1.05, okMin: 0.80, okMax: 1.15 },
      fat:     { greenMin: 0.90, greenMax: 1.10, okMin: 0.80, okMax: 1.20 },
    };

    if(modeKey === 'maint'){
      tol.carbs = { greenMin: 0.95, greenMax: 1.05, okMin: 0.90, okMax: 1.10 };
      tol.fat   = { greenMin: 0.95, greenMax: 1.05, okMin: 0.90, okMax: 1.10 };
    }
    if(modeKey === 'surplus'){
      tol.carbs = { greenMin: 0.90, greenMax: 1.10, okMin: 0.80, okMax: 1.20 };
      tol.fat   = { greenMin: 0.85, greenMax: 1.10, okMin: 0.75, okMax: 1.20 };
    }

    const t = tol[macroKey];

    let state = 'bad';
    if(ratio >= t.greenMin && ratio <= t.greenMax) state = 'good';
    else if(ratio >= t.okMin && ratio <= t.okMax) state = 'ok';

    const pct = Math.round(ratio*100);
    let label = (state==='good')?'OK':(state==='ok'?'DESV√çO':'FUERA');

    let hint='';
    if(macroKey==='protein'){
      if(ratio > t.greenMax) hint='¬∑ Baja P, sube C';
      else if(ratio < t.greenMin) hint='¬∑ Sube P';
      else hint='¬∑ Mant√©n';
    }
    return { state, label, detail: `(${pct}%) ${hint}`.trim() };
  };

  const setMacroBoxState = (boxEl, badgeEl, state, label, detail) => {
    if(!boxEl || !badgeEl) return;

    boxEl.classList.remove('good','ok','bad');
    boxEl.classList.add(state);

    const dot = badgeEl.querySelector('.dot');
    const b = badgeEl.querySelector('b');
    const spans = badgeEl.querySelectorAll('span');

    if(dot){
      dot.classList.remove('good','ok','bad');
      dot.classList.add(state==='good'?'good':(state==='ok'?'ok':'bad'));
    }
    if(b) b.textContent = label;
    if(spans.length >= 2) spans[1].textContent = detail || '';
  };

  const renderMacroStatuses = (goal, eaten, modeStored) => {
    const p = macroStatus(modeStored.modeKey, 'protein', eaten.p, goal.p);
    const c = macroStatus(modeStored.modeKey, 'carbs', eaten.c, goal.c);
    const f = macroStatus(modeStored.modeKey, 'fat', eaten.f, goal.f);

    setMacroBoxState($('eatenPBox'), $('pBadge'), p.state, p.label, p.detail);
    setMacroBoxState($('eatenCBox'), $('cBadge'), c.state, c.label, c.detail);
    setMacroBoxState($('eatenFBox'), $('fBadge'), f.state, f.label, f.detail);
  };

  // ======= UI / TABS =======
  let currentRec=null;
  let currentMacrosOk=null;

  const setTab=(t)=>{
    $('tabDay').classList.toggle('active',t==='day');
    $('tabAdd').classList.toggle('active',t==='add');
    $('screen-day').style.display=t==='day'?'':'none';
    $('screen-add').style.display=t==='add'?'':'none';
    // fuerza render para que la lista del tab A√±adir siempre se vea
    renderAll();
  bindStatsModal();
  };
  $('tabDay').onclick=()=>setTab('day');
  $('tabAdd').onclick=()=>setTab('add');

  // Drawer open/close
  const openDrawer=()=>{
    $('drawerBack').style.display='block';
    document.body.style.overflow='hidden';
    // foco al buscador de lista
    setTimeout(()=>{ $('foodsSearch')?.focus(); }, 50);
  };
  const closeDrawer=()=>{
    $('drawerBack').style.display='none';
    document.body.style.overflow='';
  };
  $('openFoods').onclick=openDrawer;
  $('closeDrawer').onclick=closeDrawer;

  // Buscador r√°pido (pantalla D√≠a) -> filtra lista de alimentos en el drawer
  const openDrawerWithSearch = (q)=>{
    openDrawer();
    if($('foodsSearch')){
      $('foodsSearch').value = String(q||'');
    }
    renderAll();
    setTimeout(()=>{ $('foodsSearch')?.focus(); }, 50);
  };

  $('globalFoodSearchBtn').onclick=()=> openDrawerWithSearch($('globalFoodSearch').value);
  $('globalFoodSearch').addEventListener('keydown',(e)=>{
    if(e.key==='Enter'){ e.preventDefault(); openDrawerWithSearch($('globalFoodSearch').value); }
  });

  // Popover buscador (lupa)
  const setSearchPop=(open)=>{
    const pop=$('globalSearchPop');
    if(!pop) return;
    pop.setAttribute('aria-hidden', open ? 'false' : 'true');
    if(open){
      setTimeout(()=>{ $('globalFoodSearch')?.focus(); }, 20);
    }
  };

  $('toggleGlobalSearch').onclick=(e)=>{
    e.preventDefault();
    const pop=$('globalSearchPop');
    const isOpen = pop?.getAttribute('aria-hidden')==='false';
    setSearchPop(!isOpen);
  };

  document.addEventListener('keydown',(e)=>{
    if(e.key==='Escape') setSearchPop(false);
  });

  document.addEventListener('click',(e)=>{
    const pop=$('globalSearchPop');
    const btn=$('toggleGlobalSearch');
    if(!pop || pop.getAttribute('aria-hidden')!=='false') return;
    const t=e.target;
    if(pop.contains(t) || btn.contains(t)) return;
    setSearchPop(false);
  });


  // Tags UI
  const getTagSetFromInput = ()=>{
    return new Set(String($('f_tags').value||'')
      .split(',')
      .map(x=>x.trim())
      .filter(Boolean));
  };

  const setTagsToInput = (set)=>{
    $('f_tags').value = Array.from(set.values()).join(', ');
  };

  const refreshTagButtons = ()=>{
    const set = getTagSetFromInput();
    document.querySelectorAll('[data-tag]').forEach(btn=>{
      const t=btn.getAttribute('data-tag');
      btn.style.outline = set.has(t) ? '2px solid var(--acc)' : '';
    });
  };

  document.addEventListener('click',(e)=>{
    const btn = e.target.closest('[data-tag]');
    if(!btn) return;
    const t = btn.getAttribute('data-tag');
    const set = getTagSetFromInput();
    if(set.has(t)) set.delete(t); else set.add(t);
    setTagsToInput(set);
    refreshTagButtons();
  });

  $('f_tags').addEventListener('input', ()=>refreshTagButtons());

  // ======= RENDER ETAPA =======
  const renderModeUI=(draft, stored)=>{
    $('modeSeg').innerHTML='';
    MODES.forEach(m=>{
      const b=document.createElement('button');
      b.textContent=m.label;
      b.className=(m.key===draft.modeKey)?'active':'';
      b.onclick=()=>{
        draft.modeKey=m.key;
        draft.levelKey=(LEVELS[m.key]||[])[0].key;
        renderAll();
      };
      $('modeSeg').appendChild(b);
    });

    $('levelSeg').innerHTML='';
    (LEVELS[draft.modeKey]||[]).forEach(l=>{
      const b=document.createElement('button');
      b.textContent=l.label;
      b.className=(l.key===draft.levelKey)?'active':'';
      b.onclick=()=>{
        draft.levelKey=l.key;
        saveModeLevelOnly(draft.levelKey);
        renderAll();
      };
      $('levelSeg').appendChild(b);
    });

    const lvlDraft=getLevel(draft.modeKey, draft.levelKey);
    const modeLbl = MODES.find(x=>x.key===draft.modeKey)?.label || '‚Äî';
    $('stageChip').textContent = `${modeLbl} ¬∑ ${lvlDraft.label}`;
    $('stageChipRight').textContent = `${modeLbl} ¬∑ ${lvlDraft.label}`;

    const stageSince = daysSince(stored.lastModeUpdateTs);
    const locked = (stageSince < STAGE_LOCK_DAYS) && !stageOverride;

    if(draft.modeKey !== stored.modeKey){
      $('stageLockHint').textContent = locked
        ? `Objetivo bloqueada: faltan ${STAGE_LOCK_DAYS - stageSince} d√≠as (o activa override).`
        : `Puedes cambiar etapa ahora.`;
    } else {
      $('stageLockHint').textContent = `Objetivo actual bloqueada ${STAGE_LOCK_DAYS} d√≠as desde el √∫ltimo cambio. Nivel diario libre.`;
    }

    $('overrideStage').textContent = stageOverride ? 'Override etapa (ON)' : 'Override etapa';
  };

  const cycleLevelByChip = ()=>{
    const stored = loadMode();
    if(stored.modeKey==='maint') return;
    const list = LEVELS[stored.modeKey] || [];
    if(list.length<=1) return;
    const idx = Math.max(0, list.findIndex(x=>x.key===stored.levelKey));
    const next = list[(idx+1) % list.length];
    saveModeLevelOnly(next.key);
    if(modeDraft){
      modeDraft.modeKey = stored.modeKey;
      modeDraft.levelKey = next.key;
    }
    renderAll();
  };

  $('stageChipPill').onclick=()=>cycleLevelByChip();

  // ======= RENDER FOODS (drawer + add tab) =======
  const renderFoodPicker=(foods)=>{
    const q = ($('foodSearch')?.value || '').trim().toLowerCase();
    if(q.length < 2){ return; }
    const sc=$('addFoodScroller');
    if(q.length < 2){ if(sc) sc.classList.add('hidden'); list.innerHTML=''; return; }
    if(sc) sc.classList.remove('hidden');
    const sel=$('foodPick'); sel.innerHTML='';
    foods
      .filter(f => !q || f.name.toLowerCase().includes(q) || f.id.toLowerCase().includes(q))
      .sort((a,b)=>a.name.localeCompare(b.name,'es'))
      .forEach(f=>{
        const o=document.createElement('option'); o.value=f.id; o.textContent=f.name; sel.appendChild(o);
      });
  };

  const renderAddFoodList=(foods)=>{
    const list=$('addFoodList');
    if(!list) return;
    list.innerHTML='';
    const q = ($('foodSearch')?.value || '').trim().toLowerCase();
    const filtered = foods
      .filter(f => !q || f.name.toLowerCase().includes(q) || f.id.toLowerCase().includes(q))
      .sort((a,b)=>a.name.localeCompare(b.name,'es'));

    if(!filtered.length){
      list.innerHTML = '<div class="muted">Sin resultados.</div>';
      return;
    }

    filtered.forEach(f=>{
      const d=document.createElement('div'); d.className='item';
      d.innerHTML = `<div><b>${f.name}</b><br><small>${f.id}</small></div>
                     <div class="right"><small>${(f.tags||[]).slice(0,4).join(', ')}</small></div>`;
      d.onclick=()=>{
        $('foodPick').value = f.id;
        // scroll a cantidad (mejor UX)
        $('qty')?.focus();
      };
      list.appendChild(d);
    });
  };

  const renderFoodsList=(foods)=>{
    const list=$('foodsList'); list.innerHTML='';
    const dev = isDev();
    // Para saber si un alimento es "usuario"
    const userArr = loadJSON(LS.foodsUser, []).map(normalizeFood);
    const userSet = new Set(userArr.map(x=>x.id));
    const hiddenSet = new Set(loadHiddenIds());

    const q = ($('foodsSearch')?.value || '').trim().toLowerCase();
    foods
      .filter(f => !q || f.name.toLowerCase().includes(q) || f.id.toLowerCase().includes(q))
      .slice()
      .sort((a,b)=>a.name.localeCompare(b.name,'es'))
      .forEach(f=>{
        const d=document.createElement('div'); d.className='item';
        d.innerHTML = `<div><b>${f.name}</b>${hiddenSet.has(f.id)?'<br><small class="muted">[OCULTO]</small>':''}<br><small>${f.id} ¬∑ ${f.baseUnit}${f.unitGrams?` ¬∑ ${f.unitGrams}g/u`:''}</small><br><small>${(f.tags||[]).join(', ')}</small></div>
                     <div class="right" style="display:flex;align-items:center;gap:10px;">
                       <div style="text-align:right;">
                         <b>${f.kcal}</b><small> kcal</small><br><small>P ${f.p} ¬∑ C ${f.c} ¬∑ F ${f.f}</small>
                       </div>
                       ${dev ? `
                         ${userSet.has(f.id) ? `<button class="delBtn" data-act="del" title="Eliminar (usuario)">üóë</button>` : `<button class="delBtn" data-act="hide" title="${hiddenSet.has(f.id)?'Mostrar':'Ocultar'} (root)">üëÅ</button>`}
                       ` : ``}
                     </div>`;

        const actBtn = d.querySelector('[data-act]');
        if(actBtn){
          actBtn.onclick=(ev)=>{
            ev.stopPropagation();
            if(!dev) return;
            const act = actBtn.getAttribute('data-act');
            if(act==='del'){
              if(confirm(`¬øEliminar "${f.name}" (usuario)?`)){
                const currentUser = loadJSON(LS.foodsUser, []).map(normalizeFood);
                saveJSON(LS.foodsUser, currentUser.filter(x=>x.id!==f.id));
                // si estaba en hidden, tambi√©n lo limpiamos
                const h = loadHiddenIds();
                if(h.includes(f.id)) saveHiddenIds(h.filter(x=>x!==f.id));
                renderAll();
              }
            } else if(act==='hide'){
              // ocultar/mostrar root sin tocar archivo
              toggleHiddenId(f.id);
              renderAll();
            }
          };
        }
        d.onclick=()=>{
          if(!dev){
            try{ navigator.clipboard?.writeText(f.id); }catch(_){ }
            alert(`ID copiado: ${f.id}`);
            return;
          }
          $('f_id').value=f.id;
          $('f_name').value=f.name;
          $('f_baseUnit').value=f.baseUnit;
          $('f_kcal').value=f.kcal;
          $('f_p').value=f.p;
          $('f_c').value=f.c;
          $('f_f').value=f.f;
          $('f_unitGrams').value=f.unitGrams??'';
          $('f_tags').value=(f.tags||[]).join(', ');
          refreshTagButtons();
          // NO reabrimos drawer: ya est√°s dentro. Solo subimos arriba.
          window.scrollTo({top:0, behavior:'smooth'});
        };
        list.appendChild(d);
      });
  };

  const renderTotals=(goal,eaten)=>{
    $('goalKcal').textContent=goal.goalKcal;
    $('tdeeKcal').textContent=goal.tdee;

    $('eatenKcal').textContent=round(eaten.kcal);
    const _rem = round(goal.goalKcal - eaten.kcal);
    const _remAbs = Math.abs(_rem);
    $('remKcal').textContent = _remAbs;
    const _lbl = $('remKcalLbl');
    if(_lbl){
      _lbl.textContent = (_rem < 0) ? 'Sobran' : 'Faltan';
    }

    const elGoalP=$('goalP'); if(elGoalP) elGoalP.textContent=goal.p;
    const elGoalC=$('goalC'); if(elGoalC) elGoalC.textContent=goal.c;
    const elGoalF=$('goalF'); if(elGoalF) elGoalF.textContent=goal.f;

    const elEP=$('eatenP'); if(elEP) elEP.textContent=round(eaten.p,1);
    const elEC=$('eatenC'); if(elEC) elEC.textContent=round(eaten.c,1);
    const elEF=$('eatenF'); if(elEF) elEF.textContent=round(eaten.f,1);
  };

  
  // ===== Macro Bars updater =====
  const fmt1=(x)=> (Math.round(x*10)/10).toString();
  const setFill=(fillEl,state,pct)=>{
    fillEl.classList.remove('good','mid','bad');
    fillEl.classList.add(state);
    fillEl.style.width = `${Math.max(0, Math.min(120, pct))}%`; // allow slight overfill up to 120%
  };
  const macroDeltaLabel=(goal, eaten, margin, unit, macroName, minVal)=>{
    const diff = goal - eaten;
    if(macroName==='fat' && minVal>0 && eaten < (minVal-0.5)){
      const need = (minVal - eaten);
      return {state:'bad', text:`Bajo m√≠nimo: faltan ${fmt1(need)} g`};
    }
    if(diff > margin) return {state:'mid', text:`Faltan ${unit==='kcal'?Math.round(diff):fmt1(diff)} ${unit}`};
    if(Math.abs(diff) <= margin) return {state:'good', text:'En rango'};
    return {state:'bad', text:`Exceso +${unit==='kcal'?Math.round(Math.abs(diff)):fmt1(Math.abs(diff))} ${unit}`};
  };
  const renderMacroBars=(goal,eaten)=>{
    const gK=Number(goal.goalKcal)||0, eK=Number(eaten.kcal)||0;
    const gP=Number(goal.p)||0, eP=Number(eaten.p)||0;
    const gF=Number(goal.f)||0, eF=Number(eaten.f)||0;
    const gC=Number(goal.c)||0, eC=Number(eaten.c)||0;

    const kcalMargin = gK*0.03;
    const pMargin = 5;
    const fMargin = 5;
    const cMargin = 15;

    const w = Number(($('weight')&&$('weight').value)||0);
    const minFat = w>0 ? (0.8*w) : 0; // m√≠nimo fisiol√≥gico recomendado

    // values
    $('barPVal').textContent = `${fmt1(eP)} / ${fmt1(gP)} g`;
    $('barFVal').textContent = `${fmt1(eF)} / ${fmt1(gF)} g`;
    $('barCVal').textContent = `${fmt1(eC)} / ${fmt1(gC)} g`;
    $('barKVal').textContent = `${Math.round(eK)} / ${Math.round(gK)} kcal`;

    // subs + state
    const pS = macroDeltaLabel(gP,eP,pMargin,'g','protein',0);
    const fS = macroDeltaLabel(gF,eF,fMargin,'g','fat',minFat);
    const cS = macroDeltaLabel(gC,eC,cMargin,'g','carb',0);
    const kS = macroDeltaLabel(gK,eK,kcalMargin,'kcal','kcal',0);

    $('barPSub').textContent = pS.text;
    $('barFSub').textContent = fS.text;
    $('barCSub').textContent = cS.text;
    $('barKSub').textContent = kS.text;

    // fill % (cap at 100 for goal, but allow up to 120 to show excess)
    const pPct = gP>0 ? (eP/gP)*100 : 0;
    const fPct = gF>0 ? (eF/gF)*100 : 0;
    const cPct = gC>0 ? (eC/gC)*100 : 0;
    const kPct = gK>0 ? (eK/gK)*100 : 0;

    setFill($('barPFill'), pS.state, pPct);
    setFill($('barFFill'), fS.state, fPct);
    setFill($('barCFill'), cS.state, cPct);
    setFill($('barKFill'), kS.state, kPct);

    // Advice coherente:
    // 1) MANDAN LAS CALOR√çAS (d√©ficit). Si kcal est√°n en rango, NO se recomienda recortar/a√±adir, solo re-balanceo.
    // 2) Prioridad: cubrir prote√≠na (si falta) -> respetar grasa m√≠nima fisiol√≥gica -> el resto se ajusta.
    const tolKcal = Math.max(100, gK*0.03);
    const kcalDiff = eK - gK; // + = pasado
    const remP = gP - eP;
    const remF = gF - eF;
    const remC = gC - eC;
    const carbExcess = eC - gC;

    const minPhysFat = w>0 ? (0.6*w) : 0; // umbral m√≠nimo (prueba contigo; no es para usuario final)
    const fatBelowMinPhys = (minPhysFat>0) && (eF < (minPhysFat - 0.1));

    let advice = '';
    if(fatBelowMinPhys){
      advice = `Sube grasas: est√°s por debajo del m√≠nimo (${fmt1(minPhysFat)} g).`;
    } else if(remP > pMargin){
      advice = `Prioridad prote√≠na: faltan ${fmt1(remP)} g. Mant√©n calor√≠as.`;
    } else if(kcalDiff < -tolKcal){
      advice = `Te faltan ${Math.round(Math.abs(kcalDiff))} kcal. Sube hidratos (y algo de grasa si te apetece).`;
    } else if(kcalDiff > tolKcal){
      advice = `Vas pasado de calor√≠as (+${Math.round(kcalDiff)} kcal). Recorta hidratos/grasas en la pr√≥xima comida.`;
    } else {
      // kcal OK: solo re-balanceo si quieres afinar
      if(remF > fMargin && carbExcess > cMargin){
        // swap kcal: grasa 9 kcal/g vs carbo 4 kcal/g
        const swapF = Math.round(remF);
        const swapC = Math.round((swapF*9)/4);
        advice = `Calor√≠as OK. Rebalanceo: sube grasas ~${swapF} g y baja carbo ~${swapC} g.`;
      } else if(remF > fMargin){
        advice = `Calor√≠as OK. Si quieres afinar, mete algo m√°s de grasas (+${fmt1(remF)} g aprox.).`;
      } else if(carbExcess > cMargin){
        advice = `Calor√≠as OK. Si quieres afinar, baja hidratos en la pr√≥xima comida.`;
      } else {
        advice = 'No cambies nada. Sigue el plan.';
      }
    }
    const advEl = $('macroAdviceText');
    if(advEl) advEl.textContent = advice;
    const hintEl = $('adviceHint');
    if(hintEl) hintEl.textContent = 'Auto';

  };
  

  // Balance vs objetivo del d√≠a (incluye el d√©ficit seleccionado). Cuando el d√≠a est√° "cuadrado" tiende a 0.
  const renderBalanceBar=(goalKcal, eatenKcal)=>{
    const elText = $('balanceText');
    const dot = $('balDot');
    if(!elText || !dot) return;
    const diff = Math.round((Number(eatenKcal)||0) - (Number(goalKcal)||0)); // + = te pasas vs objetivo, - = te falta
    const label = diff>0 ? `Balance vs objetivo: +${diff} kcal` : (diff<0 ? `Balance vs objetivo: -${Math.abs(diff)} kcal` : 'Balance vs objetivo: 0 kcal');
    elText.textContent = label;

    const cap = 800;
    const clamped = Math.max(-cap, Math.min(cap, diff)); // izquierda = te falta, derecha = te pasas
    const pct = ((clamped + cap) / (2*cap)) * 100;
    dot.style.left = `calc(${pct}% - 7px)`;
  };

// ===== End Macro Bars updater =====

  const renderDayStatus=(goal,eaten)=>{
    renderMacroBars(goal,eaten);
    renderBalanceBar(goal.goalKcal||goal.tdee||0, Number(eaten.kcal)||0);
    updateAddStatusBar(goal,eaten);

    const st=computeDayStatus(goal,eaten);
    const box=$('dayStatusBox');
    box.classList.remove('good','ok','bad');
    box.classList.add(st.state);

    const badge=$('dayStatusBadge');
    const dotClass = st.state==='good'?'good':(st.state==='ok'?'ok':'bad');
    badge.innerHTML = `<span class="dot ${dotClass}"></span> Estado del d√≠a: ${st.label}`;
    $('dayStatusDetail').textContent = st.detail;
  };


  const dateKeyFromDate=(d)=>`${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
  const pastKeys=(n)=>{
    const out=[];
    const now=new Date();
    for(let i=0;i<n;i++){
      const d=new Date(now);
      d.setDate(now.getDate()-i);
      out.push(dateKeyFromDate(d));
    }
    return out;
  };

  const normalizeDayForKey=(allSettings, key, modeKey)=>{
    const base = {
      trainTime:'',
      wod:0,
      cardioKcal:'',
      steps:'',
      neatLevel: defaultNeatByMode(modeKey),
      panicOn:false
    };
    const d = allSettings[key] ? {...base, ...allSettings[key]} : base;
    if(d.neatLevel===undefined) d.neatLevel = defaultNeatByMode(modeKey);
    return d;
  };

  const fmtKcalSigned=(x)=>{
    const r=Math.round(x);
    const s = (r>0?'+':'') + r;
    return `${s} kcal`;
  };

  const setChipClass=(el, cls)=>{
    el.classList.remove('good','bad','mid');
    el.classList.add(cls);
  };

  const computeDeficitGuidance = (profile, storedMode)=>{
    const logsAll = loadJSON(LS.logs,{});
    const settingsAll = loadJSON(LS.settings,{});

    const keys = pastKeys(7);
    let real=0;
    let planned=0;
    let dataDays=0;

    for(const k of keys){
      const items = logsAll[k] || [];
      if(!items.length) continue;
      const eaten = sumMacros(items);
      const day = normalizeDayForKey(settingsAll, k, storedMode.modeKey);
      const tdee = computeTDEE(profile, day);
      const goal = computeGoal(profile, day, storedMode);
      real += (tdee - eaten.kcal);
      planned += (tdee - goal.goalKcal);
      dataDays += 1;
    }
    if(dataDays===0) return null;

    const denom = Math.abs(planned) < 1 ? 1 : Math.abs(planned);
    const deviation = (real - planned) / denom;

    // Correcci√≥n suave: repartir desfase en 5 d√≠as
    const correctionPerDay = Math.round((planned - real) / 5);

    const absDev = Math.abs(deviation);
    let sev='ok';
    if(absDev>0.20) sev='bad';
    else if(absDev>0.10) sev='mid';

    const pct = Math.round(deviation*100);
    let msg='';
    if(storedMode.modeKey==='deficit'){
      if(real < planned) msg = `D√©ficit real por debajo del plan (${pct}%). Recomiendo ‚àí${Math.abs(correctionPerDay)} kcal/d√≠a (5 d√≠as).`;
      else if(real > planned) msg = `D√©ficit real por encima del plan (+${pct}%). Recomiendo +${Math.abs(correctionPerDay)} kcal/d√≠a (5 d√≠as).`;
      else msg = 'D√©ficit semanal en l√≠nea con el plan.';
    } else if(storedMode.modeKey==='maint'){
      msg = `Mantenimiento: balance 7d ${pct}% vs plan. Ajuste sugerido ${correctionPerDay>0?'‚àí':''}+${Math.abs(correctionPerDay)} kcal/d√≠a.`;
    } else {
      msg = `Super√°vit: balance 7d ${pct}% vs plan. Ajuste sugerido ${correctionPerDay>0?'‚àí':''}+${Math.abs(correctionPerDay)} kcal/d√≠a.`;
    }

    return {real, planned, deviation, correctionPerDay, sev, msg, dataDays};
  };

  // Compatibilidad: detalle estad√≠stico 7d (usa solo d√≠as con registro; NO cuenta futuros)
  const computeDeficitDeviation = (profile, storedMode)=>{
    const g = computeDeficitGuidance(profile, storedMode);
    if(!g) return null;
    return { real: g.real, planned: g.planned, deviation: g.deviation };
  };

  const renderHistoryChips=(profile, storedMode)=>{
    const logsAll = loadJSON(LS.logs,{});
    const settingsAll = loadJSON(LS.settings,{});
    const modeKey = storedMode.modeKey;

    const windows=[7,15,30];

    const calcWindow=(days)=>{
      const keys=pastKeys(days);
      let deficitSum=0;
      let dataDays=0;
      let adherent=0;

      for(const k of keys){
        const items = logsAll[k] || [];
        // Modo realista: si no hay registro ese d√≠a, no cuenta ni para d√©ficit ni para adherencia
        if(!items || items.length===0) continue;

        const eaten = sumMacros(items);
        const day = normalizeDayForKey(settingsAll, k, modeKey);

        const tdee = computeTDEE(profile, day);
        deficitSum += (tdee - eaten.kcal);

        dataDays += 1;

        const goal = computeGoal(profile, day, storedMode);
        const kcalOk = goal.goalKcal>0 ? (Math.abs(eaten.kcal-goal.goalKcal)/goal.goalKcal)<=0.05 : false;
        const pOk = goal.p>0 ? eaten.p >= (goal.p*0.95) : false;
        if(kcalOk && pOk) adherent += 1;
      }

      const adhPct = dataDays>0 ? Math.round((adherent/dataDays)*100) : null;
      return {deficitSum, adhPct, adherent, dataDays};
    };

    const w7=calcWindow(7), w15=calcWindow(15), w30=calcWindow(30);

    const setDef=(chipId,valId,w)=>{
      const chip=$(chipId), val=$(valId);
      if(!w || !w.dataDays){
        val.textContent='‚Äî';
        setChipClass(chip,'mid');
        chip.title='Sin d√≠as con registro en esa ventana';
        return;
      }
      val.textContent = fmtKcalSigned(w.deficitSum);
      // Color seg√∫n etapa
      const mk = storedMode.modeKey;
      let good = true;
      if(mk==='surplus') good = w.deficitSum<0;
      else if(mk==='maint') good = Math.abs(w.deficitSum) <= 1500;
      else good = w.deficitSum>0; // deficit
      setChipClass(chip, good ? 'good' : 'bad');
      chip.title = `Acumulado sobre ${w.dataDays} d√≠a(s) con registro`;
    };

    const setAdh=(chipId,valId,w)=>{
      const chip=$(chipId), val=$(valId);
      if(w.adhPct===null){
        val.textContent='‚Äî';
        setChipClass(chip,'mid');
        chip.title='Sin d√≠as con registro en esa ventana';
        return;
      }
      val.textContent = `${w.adhPct}% (${w.adherent}/${w.dataDays})`;
      if(w.adhPct>=80) setChipClass(chip,'good');
      else if(w.adhPct>=60) setChipClass(chip,'mid');
      else setChipClass(chip,'bad');
    };

    setDef('def7Chip','def7Val',w7);
    setDef('def15Chip','def15Val',w15);
    setDef('def30Chip','def30Val',w30);

    setAdh('adh7Chip','adh7Val',w7);
    setAdh('adh15Chip','adh15Val',w15);
    setAdh('adh30Chip','adh30Val',w30);
  };

  const renderRec=(rec)=>{
    const list=$('recList'); list.innerHTML='';
    if(!rec){ list.innerHTML='<div class="muted">Sin recomendaci√≥n.</div>'; return; }

    rec.items.forEach(it=>{
      const d=document.createElement('div'); d.className='item';
      d.innerHTML = `<div><b>${it.name}</b><br><small>${it.qtyDisplay}</small></div>
                     <div class="right"><b>${it.kcal}</b><small> kcal</small><br><small>P ${it.p} ¬∑ C ${it.c} ¬∑ F ${it.f}</small></div>`;
      list.appendChild(d);
    });

    const s=document.createElement('div'); s.className='item';
    s.innerHTML=`<div><b>Total recomendaci√≥n</b><br><small>${rec.ctx} ¬∑ ${prettyMeal(rec.slot)}</small></div>
                 <div class="right"><b>${round(rec.tot.kcal)}</b><small> kcal</small><br><small>P ${round(rec.tot.p,1)} ¬∑ C ${round(rec.tot.c,1)} ¬∑ F ${round(rec.tot.f,1)}</small></div>`;
    list.appendChild(s);
  };

  const renderLog=(foods,items)=>{
    const list=$('logList'); list.innerHTML='';
    if(!items.length){ list.innerHTML='<div class="muted">A√∫n no hay registros hoy.</div>'; return; }

    const groups = new Map();
    items.forEach((it, idx)=>{
      const m = normalizeMealLabel(it.meal);
      if(!groups.has(m)) groups.set(m, []);
      groups.get(m).push({it, idx});
    });

    const entries = Array.from(groups.entries()).sort((a,b)=> mealOrder(a[0]) - mealOrder(b[0]));

    for(const [mealKey, arr] of entries){
      const tot = arr.reduce((acc, x)=>({
        kcal: acc.kcal + (Number(x.it.kcal)||0),
        p: acc.p + (Number(x.it.p)||0),
        c: acc.c + (Number(x.it.c)||0),
        f: acc.f + (Number(x.it.f)||0),
      }),{kcal:0,p:0,c:0,f:0});

      const block=document.createElement('details');
      block.open = (mealKey === $('mealSlot').value);

      const sum=document.createElement('summary');
      sum.className='groupSummary';
      sum.innerHTML = `
        <div>
          <b>${prettyMeal(mealKey)}</b><br>
          <small><b>${round(tot.kcal)}</b> kcal ¬∑ P ${round(tot.p,1)} ¬∑ C ${round(tot.c,1)} ¬∑ F ${round(tot.f,1)}</small>
        </div>
        <button class="miniBtn" type="button">+ A√±adir</button>
      `;
      block.appendChild(sum);

      sum.querySelector('.miniBtn').onclick=(ev)=>{
        ev.preventDefault(); ev.stopPropagation();
        $('mealSlot').value = mealKey;
        setTab('add');
      };

      const wrap=document.createElement('div');
      wrap.className='groupWrap';

      arr.forEach(({it, idx})=>{
        const d=document.createElement('div'); d.className='item';
        d.innerHTML = `
          <div>
            <b>${it.name}</b><br>
            <small>${it.qtyDisplay}</small>
          </div>
          <div class="right" style="display:flex;align-items:center;gap:10px;">
            <div>
              <b>${it.kcal}</b><small> kcal</small><br>
              <small>P ${it.p} ¬∑ C ${it.c} ¬∑ F ${it.f}</small>
            </div>
            <button class="delBtn" title="Eliminar">üóë</button>
          </div>
        `;

        d.querySelector('.delBtn').onclick=(ev)=>{
          ev.stopPropagation();
          if(confirm(`¬øEliminar "${it.name}"?`)){
            items.splice(idx,1);
            saveLogs(activeDayKey, items);
            renderAll();
          }
        };

        d.onclick=()=>{
          const action = prompt(
            `Editar "${it.name}"\n\nFormato: 200 g | 2 u | 250 ml\nPara borrar: DEL`,
            `${it.qty} ${it.qtyType==='unit'?'u':(it.qtyType==='ml'?'ml':'g')}`
          );
          if(action===null) return;

          const txt=action.trim().toLowerCase();
          if(txt==='del' || txt==='borrar' || txt==='delete' || txt==='x'){
            if(confirm(`¬øEliminar "${it.name}"?`)){
              items.splice(idx,1);
              saveLogs(activeDayKey, items);
              renderAll();
            }
            return;
          }

          const m=txt.match(/^(\d+(?:[.,]\d+)?)\s*(g|gr|u|ud|uds|ml)$/i);
          if(!m){ alert('Formato inv√°lido. Ej: 200 g / 2 u / 250 ml'); return; }

          const qty=Number(m[1].replace(',','.'));
          const u=m[2].toLowerCase();
          const qtyType=(u==='ml')?'ml':(u.startsWith('u')?'unit':'g');

          const f=foodById(foods,it.foodId);
          if(!f){ alert('No encuentro el alimento en base de datos.'); return; }

          const mac=macroFor(f,qtyType,qty);
          it.qty=qty;
          it.qtyType=qtyType;
          it.qtyDisplay=qtyDisplay(qtyType,qty);
          it.kcal=mac.kcal; it.p=mac.p; it.c=mac.c; it.f=mac.f;

          saveLogs(activeDayKey, items);
          renderAll();
        };

        wrap.appendChild(d);
      });

      block.appendChild(wrap);
      list.appendChild(block);
    }
  };

  // ======= MACROS OK RENDER + EDIT =======
  const renderMacrosOk = ()=>{
    const list=$('macrosOkList');
    list.innerHTML='';

    if(!currentMacrosOk || !currentMacrosOk.items || !currentMacrosOk.items.length){
      list.innerHTML = '<div class="muted">Sin sugerencia a√∫n.</div>';
      return;
    }

    const groups = new Map();
    currentMacrosOk.items.forEach((it, idx)=>{
      const m = normalizeMealLabel(it.meal);
      if(!groups.has(m)) groups.set(m, []);
      groups.get(m).push({it, idx});
    });

    const entries = Array.from(groups.entries()).sort((a,b)=>mealOrder(a[0]) - mealOrder(b[0]));

    for(const [mealKey, arr] of entries){
      const tot = arr.reduce((acc, x)=>({
        kcal: acc.kcal + (Number(x.it.kcal)||0),
        p: acc.p + (Number(x.it.p)||0),
        c: acc.c + (Number(x.it.c)||0),
        f: acc.f + (Number(x.it.f)||0),
      }),{kcal:0,p:0,c:0,f:0});

      const header=document.createElement('div');
      header.className='item';
      header.innerHTML = `<div><b>${prettyMeal(mealKey)} (plan)</b><br><small>${arr.length} items</small></div>
        <div class="right"><b>${round(tot.kcal)}</b><small> kcal</small><br><small>P ${round(tot.p,1)} ¬∑ C ${round(tot.c,1)} ¬∑ F ${round(tot.f,1)}</small></div>`;
      list.appendChild(header);

      arr.forEach(({it, idx})=>{
        const d=document.createElement('div'); d.className='item';
        d.innerHTML = `<div><b>${it.name}</b><br><small>${it.qtyDisplay}</small></div>
                       <div class="right"><b>${it.kcal}</b><small> kcal</small><br><small>P ${it.p} ¬∑ C ${it.c} ¬∑ F ${it.f}</small></div>`;
        d.onclick=()=>{
          const action = prompt(
            `Editar sugerencia "${it.name}"\n\nFormato: 200 g | 2 u | 250 ml\nPara borrar: DEL`,
            `${it.qty} ${it.qtyType==='unit'?'u':(it.qtyType==='ml'?'ml':'g')}`
          );
          if(action===null) return;

          const txt=action.trim().toLowerCase();
          if(txt==='del' || txt==='borrar' || txt==='delete' || txt==='x'){
            currentMacrosOk.items.splice(idx,1);
            recalcMacrosOkTotals();
            renderMacrosOk();
            return;
          }

          const m=txt.match(/^(\d+(?:[.,]\d+)?)\s*(g|gr|u|ud|uds|ml)$/i);
          if(!m){ alert('Formato inv√°lido. Ej: 200 g / 2 u / 250 ml'); return; }

          const qty=Number(m[1].replace(',','.'));
          const u=m[2].toLowerCase();
          const qtyType=(u==='ml')?'ml':(u.startsWith('u')?'unit':'g');

          const foods=loadFoodsMerged({ includeHidden:false });

    // para gesti√≥n en drawer (dev puede ver ocultos)
    const foodsForDrawer = loadFoodsMerged({ includeHidden: isDev() });
          const f=foodById(foods,it.foodId);
          if(!f){ alert('No encuentro el alimento en base de datos.'); return; }

          const mac=macroFor(f,qtyType,qty);
          it.qty=qty;
          it.qtyType=qtyType;
          it.qtyDisplay=qtyDisplay(qtyType,qty);
          it.kcal=mac.kcal; it.p=mac.p; it.c=mac.c; it.f=mac.f;

          recalcMacrosOkTotals();
          renderMacrosOk();
        };
        list.appendChild(d);
      });
    }

    const s=document.createElement('div'); s.className='item';
    s.innerHTML=`<div><b>Total plan (Cuadrar D√≠a)</b><br><small>Se a√±adir√° al registro al confirmar</small></div>
                 <div class="right"><b>${round(currentMacrosOk.tot.kcal)}</b><small> kcal</small><br><small>P ${round(currentMacrosOk.tot.p,1)} ¬∑ C ${round(currentMacrosOk.tot.c,1)} ¬∑ F ${round(currentMacrosOk.tot.f,1)}</small></div>`;
    list.appendChild(s);
  };

  const recalcMacrosOkTotals = ()=>{
    if(!currentMacrosOk) return;
    const tot = currentMacrosOk.items.reduce((a,x)=>({
      kcal:a.kcal+(Number(x.kcal)||0),
      p:a.p+(Number(x.p)||0),
      c:a.c+(Number(x.c)||0),
      f:a.f+(Number(x.f)||0),
    }),{kcal:0,p:0,c:0,f:0});
    currentMacrosOk.tot = tot;
  };

  // ======= ROLLOVER =======
  const rolloverIfNeeded=()=>{
    const last=localStorage.getItem(LS.lastDate);
    const now=todayKey();
    if(!last){
      localStorage.setItem(LS.lastDate, now);
      return false;
    }
    if(last===now) return false;

    const storedMode=loadMode();
    ensureDaySettings(now, storedMode.modeKey);
    // al cambiar de d√≠a, el foco pasa al d√≠a en curso
    activeDayKey = now;

    localStorage.setItem(LS.lastDate, now);
    return true;
  };

  // ======= RENDER ALL =======
  const renderAll=()=>{
    rolloverIfNeeded();
    renderWeekChips();

    const foods=loadFoodsMerged({ includeHidden:false });
    const foodsForDrawer=loadFoodsMerged({ includeHidden: isDev() });

    const storedMode=loadMode();
    if(!modeDraft) modeDraft = {...storedMode};

    renderModeUI(modeDraft, storedMode);

    const profile=loadProfile();
    $('sex').value = profile.sex;
    $('age').value = profile.age;
    $('heightCm').value = profile.heightCm;

    $('dateChip').textContent = activeDayKey;
    $('weightChip').textContent = `${profile.weightKg} kg`;

    const sinceW = daysSince(profile.lastWeightUpdateTs);
    const lockedW = (sinceW < WEIGHT_LOCK_DAYS) && !weightOverride;
    $('weightKg').value = profile.weightKg;
    $('weightKg').disabled = lockedW;
    $('weightLockHint').textContent = lockedW ? `¬∑ Bloqueado (${WEIGHT_LOCK_DAYS - sinceW} d√≠as)` : '';

    const {day}=loadDaySettings(activeDayKey, storedMode.modeKey);

    const isLocked = (activeDayKey < todayKey());
    $('trainTime').value = day.trainTime || '';
    $('wod').value = String(day.wod ?? 350);
    $('cardioKcal').value = day.cardioKcal ?? '';
    $('steps').value = day.steps ?? '';
    $('neatLevel').value = day.neatLevel ?? defaultNeatByMode(storedMode.modeKey);

    const pal = PAL[$('neatLevel').value] || PAL.high;
    const bmr = computeBMR(profile);
    $('neatInfo').textContent = `PAL aplicado: ${pal} ¬∑ TMB: ${bmr} kcal`;

    // P√°nico (estado visual)
    $('panicBtn').textContent = day.panicOn ? 'P√°nico (ON)' : 'P√°nico';
    $('panicBtn').style.outline = day.panicOn ? '2px solid rgba(255,77,77,.55)' : '';

    renderFoodPicker(foods);
    renderAddFoodList(foods);
    try{ renderRecentFoods(foods); const f=foodById(foods,$('foodPick').value); if(f) applyQtyModeForFood(f);}catch(e){}
    renderFoodsList(foodsForDrawer);

    const logs=loadLogs(activeDayKey).items;
    const eaten=sumMacros(logs);
    const goal=computeGoal(profile, day, storedMode);

    renderTotals(goal,eaten);
    renderDayStatus(goal,eaten);
    try{ updateMiniSticky(goal,eaten); }catch(e){}
    renderHistoryChips(profile, storedMode);

    // Guidance por desviaci√≥n acumulada 7d
    const guidance = computeDeficitGuidance(profile, storedMode);
    let adjustedGoal = goal;
    if(guidance){
      const absDev = Math.abs(guidance.deviation);
      if(absDev>0.20){
        $('dayStatusDetail').textContent += ` ¬∑ ${guidance.msg}`;
      }
      if((activeDayKey >= todayKey()) && absDev>0.15){
        adjustedGoal = { ...goal, goalKcal: Math.max(0, goal.goalKcal - guidance.correctionPerDay) };
      }
    }

    renderMacroStatuses(goal, eaten, storedMode);
    renderLog(foods,logs);

    const tc=timeContext(day.trainTime);
    const slot=mealFromClock();
    let recCtx = `${tc.ctx} ¬∑ ${prettyMeal(slot)}: ${tc.detail}`;
    if(guidance && guidance.dataDays>=3){
      const absDev = Math.abs(guidance.deviation);
      if(absDev>0.15) recCtx += ` ¬∑ Correcci√≥n 7d: ${guidance.correctionPerDay>0?'-':'+'}${Math.abs(guidance.correctionPerDay)} kcal/d√≠a (5d)`;
    }
    $('recContext').textContent = recCtx;

    const rec = recommendForSlot(foods, adjustedGoal, eaten, tc.ctx, slot, false);
    currentRec = rec ? {slot, ctx:tc.ctx, items:rec.items, tot:rec.tot} : null;
    renderRec(currentRec);

    renderMacrosOk();
    // resumen en cabecera del panel Macros OK
    const _sumEl = $('macrosOkSummaryLine');
    if(_sumEl){
      const _rem = $('remKcal')?.textContent || '‚Äî';
      const _n = currentMacrosOk?.items?.length || 0;
      _sumEl.textContent = _n ? `${_n} √≠tems ¬∑ ${_rem} kcal` : 'Sin sugerencia';
    }

    // lock day (solo consulta) si es pasado
    /* lock day */
    const lockables = document.querySelectorAll('#screen-day input, #screen-day select, #screen-day textarea, #screen-day button, #screen-add input, #screen-add select, #screen-add textarea, #screen-add button');
    lockables.forEach(el=>{
      if(el.closest('#weekChips')) return;
      if(el.id==='tabDay' || el.id==='tabAdd') return;
      if(isLocked){
        if(el.id==='openFoods' || el.id==='toggleGlobalSearch') return;
        el.disabled = true;
      } else {
        el.disabled = false;
      }
    });

    refreshTagButtons();
    applyDevUI();
  };

  // ======= ACTIONS =======
  $('overrideWeight').onclick=()=>{
    weightOverride = !weightOverride;
    alert(weightOverride ? 'Override peso activado.' : 'Override peso desactivado.');
    renderAll();
  };

  $('saveProfile').onclick=()=>{
    const p = loadProfile();

    const next = {
      sex: ($('sex').value==='f')?'f':'m',
      age: Math.max(10, Number($('age').value)||p.age),
      heightCm: Math.max(120, Number($('heightCm').value)||p.heightCm),
      weightKg: Math.max(30, Number($('weightKg').value)||p.weightKg),
      lastWeightUpdateTs: p.lastWeightUpdateTs
    };

    const weightChanged = Math.abs(next.weightKg - p.weightKg) > 0.0001;

    const since = daysSince(p.lastWeightUpdateTs);
    const locked = (since < WEIGHT_LOCK_DAYS) && !weightOverride;

    if(weightChanged && locked){
      alert(`Peso bloqueado. Faltan ${WEIGHT_LOCK_DAYS - since} d√≠as (o activa override).`);
      renderAll();
      return;
    }

    if(weightChanged){
      next.lastWeightUpdateTs = Date.now();
      weightOverride = false;
    }

    saveProfile(next);
    alert('Perfil guardado.');
    renderAll();
  };

  $('overrideStage').onclick=()=>{
    stageOverride = !stageOverride;
    alert(stageOverride ? 'Override etapa activado.' : 'Override etapa desactivado.');
    renderAll();
  };

  $('saveStage').onclick=()=>{
    const stored=loadMode();
    const wantsChangeMode = modeDraft.modeKey !== stored.modeKey;

    if(wantsChangeMode){
      const since = daysSince(stored.lastModeUpdateTs);
      const locked = (since < STAGE_LOCK_DAYS) && !stageOverride;
      if(locked){
        alert(`Objetivo bloqueada. Faltan ${STAGE_LOCK_DAYS - since} d√≠as (o activa override).`);
        renderAll();
        return;
      }
      saveModeFull(modeDraft.modeKey, modeDraft.levelKey);
      stageOverride = false;
      alert('Objetivo guardada.');
      renderAll();
      return;
    }

    alert('Objetivo sin cambios. El nivel diario se guarda al seleccionarlo.');
  };

  $('panicBtn').onclick=()=>{
    const storedMode=loadMode();
    const {day}=loadDaySettings(activeDayKey, storedMode.modeKey);

    const isLocked = (activeDayKey < todayKey());
    day.panicOn = !day.panicOn;
    saveDaySettings(activeDayKey, day);
    alert(day.panicOn
      ? `P√°nico activado: se resta ${(loadProfile().sex==='m'?400:300)} kcal al objetivo HOY.`
      : 'P√°nico desactivado.');
    renderAll();
  };

  $('saveDay').onclick=()=>{
    const storedMode=loadMode();
    const {day:cur}=loadDaySettings(activeDayKey, storedMode.modeKey);
    const day={
      ...cur,
      trainTime: $('trainTime').value || '',
      wod: Number($('wod').value) || 0,
      cardioKcal: $('cardioKcal').value,
      steps: $('steps').value,
      neatLevel: $('neatLevel').value || defaultNeatByMode(storedMode.modeKey),
    };
    saveDaySettings(activeDayKey, day);
    alert('Guardado.');
    renderAll();
  };

  $('foodSearch').addEventListener('input', ()=>renderAll());
  $('foodsSearch').addEventListener('input', ()=>renderAll());
  $('clearFoodsSearch').onclick=()=>{
    $('foodsSearch').value='';
    renderAll();
  };

  const pushLogItem = (logs, payload)=>{
    logs.push({
      ts: Date.now(),
      meal: normalizeMealLabel(payload.meal),
      foodId: payload.foodId,
      name: payload.name,
      qtyType: payload.qtyType,
      qty: payload.qty,
      qtyDisplay: payload.qtyDisplay,
      kcal: payload.kcal, p: payload.p, c: payload.c, f: payload.f
    });
  };

  $('addItem').onclick=()=>{
    const foods=loadFoodsMerged();
    const f=foodById(foods,$('foodPick').value);
    const qtyType=$('qtyType').value;
    const qty=Number($('qty').value);
    if(!f || !qty || qty<=0){ alert('Producto y cantidad.'); return; }

    const mac=macroFor(f,qtyType,qty);
    const logs=loadLogs(activeDayKey).items;

    pushLogItem(logs,{
      meal: $('mealSlot').value,
      foodId: f.id,
      name: f.name,
      qtyType, qty,
      qtyDisplay: qtyDisplay(qtyType,qty),
      ...mac
    });

    saveLogs(activeDayKey, logs);
    $('qty').value='';
    $('foodSearch').value='';
    $('foodSearch').focus();
    renderAll();
  };

  $('parseQuick').onclick=()=>{
    const txt=$('quickText').value.trim();
    if(!txt){ alert('Pega texto.'); return; }

    const foods=loadFoodsMerged();
    const logs=loadLogs(activeDayKey).items;
    const lines=txt.split(/\n+/).map(x=>x.trim()).filter(Boolean);
    let added=0;

    for(const line of lines){
      const m=line.match(/(.+?)\s+(\d+(?:[.,]\d+)?)\s*(g|gr|u|ud|uds|ml)\b/i);
      if(!m) continue;

      const needle=m[1].trim().toLowerCase();
      const qty=Number(String(m[2]).replace(',','.'));
      const u=m[3].toLowerCase();
      const qtyType=(u==='ml')?'ml':(u.startsWith('u')?'unit':'g');

      const f=foods.find(x=>x.id.toLowerCase()===needle) || foods.find(x=>x.name.toLowerCase().includes(needle));
      if(!f) continue;

      const mac=macroFor(f,qtyType,qty);
      pushLogItem(logs,{
        meal: $('mealSlot').value,
        foodId: f.id,
        name: f.name,
        qtyType, qty,
        qtyDisplay: qtyDisplay(qtyType,qty),
        ...mac
      });
      added++;
    }

    saveLogs(activeDayKey, logs);
    $('quickText').value='';
    alert(`A√±adidos: ${added}`);
    renderAll();
  };

  $('regenRec').onclick=()=>{
    const foods=loadFoodsMerged();
    const storedMode=loadMode();
    const {day}=loadDaySettings(activeDayKey, storedMode.modeKey);

    const isLocked = (activeDayKey < todayKey());
    const profile=loadProfile();
    const logs=loadLogs(activeDayKey).items;
    const eaten=sumMacros(logs);
    const goal=computeGoal(profile, day, storedMode);
    const guidance = computeDeficitGuidance(profile, storedMode);
    const adjustedGoal = (guidance && (activeDayKey >= todayKey()) && Math.abs(guidance.deviation)>0.15)
      ? { ...goal, goalKcal: Math.max(0, goal.goalKcal - guidance.correctionPerDay) }
      : goal;
    const tc=timeContext(day.trainTime);
    const slot=mealFromClock();

    const rec = recommendForSlot(foods, adjustedGoal, eaten, tc.ctx, slot, true);
    currentRec = rec ? {slot, ctx:tc.ctx, items:rec.items, tot:rec.tot} : null;
    renderRec(currentRec);
  };

  $('addRecToLog').onclick=()=>{
    if(!currentRec){ alert('No hay recomendaci√≥n.'); return; }
    const logs=loadLogs(activeDayKey).items;

    currentRec.items.forEach(it=>{
      pushLogItem(logs,{
        meal: currentRec.slot,
        foodId: it.foodId,
        name: it.name,
        qtyType: it.qtyType,
        qty: it.qty,
        qtyDisplay: it.qtyDisplay,
        kcal: it.kcal, p: it.p, c: it.c, f: it.f
      });
    });

    saveLogs(activeDayKey, logs);
    renderAll();
  };

  $('clearToday').onclick=()=>{
    if(confirm('¬øBorrar todo HOY?')){
      saveLogs(activeDayKey, []);
      renderAll();
    }
  };

  // Macros OK
  $('macrosOkGen').onclick=()=>{
    const foods=loadFoodsMerged();
    const storedMode=loadMode();
    const {day}=loadDaySettings(activeDayKey, storedMode.modeKey);

    const isLocked = (activeDayKey < todayKey());
    const profile=loadProfile();
    const {items:logs}=loadLogs(activeDayKey);
    const goal=computeGoal(profile, day, storedMode);
    const guidance = computeDeficitGuidance(profile, storedMode);
    const adjustedGoal = (guidance && (activeDayKey >= todayKey()) && Math.abs(guidance.deviation)>0.15)
      ? { ...goal, goalKcal: Math.max(0, goal.goalKcal - guidance.correctionPerDay) }
      : goal;

    currentMacrosOk = planMacrosOk(foods, adjustedGoal, logs, day);

    $('macrosOkContext').textContent = currentMacrosOk?.context || 'Sin sugerencia.';
    renderMacrosOk();
  };

  $('macrosOkConfirm').onclick=()=>{
    if(!currentMacrosOk || !currentMacrosOk.items || !currentMacrosOk.items.length){
      alert('No hay sugerencia para confirmar.');
      return;
    }
    const logs=loadLogs(activeDayKey).items;

    currentMacrosOk.items.forEach(it=>{
      pushLogItem(logs,{
        meal: it.meal,
        foodId: it.foodId,
        name: it.name,
        qtyType: it.qtyType,
        qty: it.qty,
        qtyDisplay: it.qtyDisplay,
        kcal: it.kcal, p: it.p, c: it.c, f: it.f
      });
    });

    saveLogs(activeDayKey, logs);
    currentMacrosOk = null;
    $('macrosOkContext').textContent = 'Sugerencia confirmada y a√±adida al registro.';
    renderAll();
  };

  // CRUD alimentos
  $('saveFood').onclick=()=>{
    const id=$('f_id').value.trim();
    const name=$('f_name').value.trim();
    if(!id || !name){ alert('id y nombre obligatorios'); return; }

    const obj=normalizeFood({
      id, name,
      baseUnit: $('f_baseUnit').value,
      kcal: Number($('f_kcal').value),
      p: Number($('f_p').value),
      c: Number($('f_c').value),
      f: Number($('f_f').value),
      unitGrams: ($('f_unitGrams').value.trim()?Number($('f_unitGrams').value):null),
      tags: $('f_tags').value
    });

    if(!isFinite(obj.kcal)||!isFinite(obj.p)||!isFinite(obj.c)||!isFinite(obj.f)){
      alert('Macros inv√°lidos.');
      return;
    }

    upsertFoodFromApp(obj);
    alert('Guardado (usuario).');
    renderAll();
  };

  
  // Eliminar alimento (solo usuario) + ocultar/mostrar root (dev)
  $('deleteFood').onclick=()=>{
    if(!isDev()){ alert('Bloqueado.'); return; }
    const id=$('f_id').value.trim();
    if(!id){ alert('Selecciona un alimento.'); return; }
    if(!confirm(`¬øEliminar "${id}" del usuario?`)) return;

    const currentUser = loadJSON(LS.foodsUser, []).map(normalizeFood);
    const exists = currentUser.some(x=>x.id===id);
    if(!exists){
      alert('Este alimento es del n√∫cleo (root). Para quitarlo, usa ‚ÄúOcultar / Mostrar (root)‚Äù.');
      return;
    }
    saveJSON(LS.foodsUser, currentUser.filter(x=>x.id!==id));
    // limpiar form
    ['f_id','f_name','f_kcal','f_p','f_c','f_f','f_unitGrams','f_tags'].forEach(k=>{ const el=$(k); if(el) el.value=''; });
    alert('Eliminado.');
    renderAll();
  };

  $('toggleHideFood').onclick=()=>{
    if(!isDev()){ alert('Bloqueado.'); return; }
    const id=$('f_id').value.trim();
    if(!id){ alert('Selecciona un alimento.'); return; }

    // si es usuario, mejor eliminar
    const currentUser = loadJSON(LS.foodsUser, []).map(normalizeFood);
    if(currentUser.some(x=>x.id===id)){
      alert('Este alimento es de usuario. Usa ‚ÄúEliminar alimento‚Äù.');
      return;
    }

    toggleHiddenId(id);
    alert(isHiddenId(id) ? 'Ocultado (root).' : 'Visible (root).');
    renderAll();
  };
$('exportFoods').onclick=()=>{
    const foods=loadFoodsMerged();
    const blob=new Blob([JSON.stringify(foods,null,2)],{type:'application/json'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download='macrocontrolapp_foods_merged.json'; a.click();
    URL.revokeObjectURL(url);
  };

  $('importFoodsBtn').onclick=()=>$('importFoodsFile').click();
  $('importFoodsFile').onchange=(ev)=>{
    const file=ev.target.files[0]; if(!file) return;
    const r=new FileReader();
    r.onload=()=>{
      try{
        const data=JSON.parse(r.result);
        if(!Array.isArray(data)) throw new Error('No es una lista');

        const incoming = data.map(normalizeFood).filter(x=>x.id && x.name);
        ensureFoodsStores();
        const currentUser = loadJSON(LS.foodsUser, []).map(normalizeFood);
        const mergedUser = uniqByIdPreferLast([...currentUser, ...incoming]);
        saveJSON(LS.foodsUser, mergedUser);

        alert(`Importado a usuario: ${incoming.length}`);
        renderAll();
      }catch(e){
        alert('JSON inv√°lido: '+e.message);
      }
    };
    r.readAsText(file);
  };

  // Rules Engine (DEV): import/export configuraci√≥n de maridajes/caps
  $('exportRules') && ($('exportRules').onclick=()=>{
    try{
      const rules = loadJSON(LS.rulesEngine, null) || DEFAULT_RULES_ENGINE;
      const blob=new Blob([JSON.stringify(rules,null,2)],{type:'application/json'});
      const url=URL.createObjectURL(blob);
      const a=document.createElement('a'); a.href=url; a.download='macrocontrol_rules_engine.json'; a.click();
      URL.revokeObjectURL(url);
    }catch(e){ alert('No se pudieron exportar las reglas.'); }
  });

  $('importRulesBtn') && ($('importRulesBtn').onclick=()=>$('importRulesFile').click());
  $('importRulesFile') && ($('importRulesFile').onchange=(ev)=>{
    const file=ev.target.files[0]; if(!file) return;
    const r=new FileReader();
    r.onload=()=>{
      try{
        const obj=JSON.parse(r.result);
        const valid = validateRulesEngine(obj);
        saveJSON(LS.rulesEngine, valid);
        alert('Rules Engine importado.');
        renderAll();
      }catch(e){
        alert('Rules Engine inv√°lido: '+(e.message||'error'));
      }
    };
    r.readAsText(file);
    ev.target.value='';
  });

  $('resetRules') && ($('resetRules').onclick=()=>{
    if(!confirm('Restaurar reglas por defecto eliminar√° tu Rules Engine personalizado. ¬øContinuar?')) return;
    localStorage.removeItem(LS.rulesEngine);
    alert('Rules Engine restaurado (por defecto).');
    renderAll();
  });


  // Trace Cuadrar D√≠a (DEV)
  $('viewLastTrace') && ($('viewLastTrace').onclick=()=>{
    const t = mcLoadLastPlanTrace();
    if(!t){ alert('No hay trace guardado. Genera Cuadrar D√≠a primero.'); return; }
    $('traceText').value = JSON.stringify(t, null, 2);
    $('traceModal').style.display='block';
  });

  $('clearLastTrace') && ($('clearLastTrace').onclick=()=>{
    localStorage.removeItem('mc_last_plan_trace');
    try{ delete window.__mc_lastPlanTrace; }catch(e){}
    alert('Trace borrado.');
  });

  $('closeTrace') && ($('closeTrace').onclick=()=>{ $('traceModal').style.display='none'; });

  $('copyTrace') && ($('copyTrace').onclick=async()=>{
    try{
      await navigator.clipboard.writeText($('traceText').value || '');
      alert('Copiado.');
    }catch(e){
      // fallback iOS
      $('traceText').select();
      document.execCommand('copy');
      alert('Copiado.');
    }
  });

  // Backup r√°pido (DEV): export/import estado completo (perfil + settings + logs + foods usuario)
  const applyBackupState = (state)=>{
    if(!state || typeof state!=='object') throw new Error('Backup inv√°lido');
    if(state.mode!=null) saveJSON(LS.mode, state.mode);
    if(state.settings!=null) saveJSON(LS.settings, state.settings);
    if(state.logs!=null) saveJSON(LS.logs, state.logs);
    if(state.lastDate!=null) saveJSON(LS.lastDate, state.lastDate);
    if(state.profile!=null) saveJSON(LS.profile, state.profile);
    if(state.rulesEngine!=null) saveJSON(LS.rulesEngine, state.rulesEngine);
    if(state.foodsUser!=null) saveJSON(LS.foodsUser, state.foodsUser);
    if(state.foodsHidden!=null) saveJSON(DEV_HIDDEN_KEY, state.foodsHidden);
    if(state.devMode!=null) localStorage.setItem(DEV_MODE_KEY, String(state.devMode));
    saveBackupLast();
  };

  const makeBackupFilename = ()=>{
    const d=new Date();
    const pad=n=>String(n).padStart(2,'0');
    return `macrocontrol_backup_${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}.json`;
  };

  $('exportBackup') && ($('exportBackup').onclick=()=>{
    try{
      const blob=new Blob([JSON.stringify(snapshotState(),null,2)],{type:'application/json'});
      const url=URL.createObjectURL(blob);
      const a=document.createElement('a'); a.href=url; a.download=makeBackupFilename(); a.click();
      URL.revokeObjectURL(url);
    }catch(e){ alert('No se pudo exportar el backup.'); }
  });

  $('makeBackupNow') && ($('makeBackupNow').onclick=()=>{
    saveBackupLast();
    alert('Copia guardada (local).');
  });

  $('restoreLastBackup') && ($('restoreLastBackup').onclick=()=>{
    try{
      const raw=localStorage.getItem(BACKUP_LAST_KEY);
      if(!raw) return alert('No hay backup local.');
      const state=JSON.parse(raw);
      if(!confirm('Restaurar el √∫ltimo backup local reemplazar√° tus datos actuales. ¬øContinuar?')) return;
      applyBackupState(state);
      alert('Backup restaurado.');
      renderAll();
    }catch(e){ alert('No se pudo restaurar el backup.'); }
  });

  $('importBackupBtn') && ($('importBackupBtn').onclick=()=>$('importBackupFile').click());
  $('importBackupFile') && ($('importBackupFile').onchange=(ev)=>{
    const file=ev.target.files[0]; if(!file) return;
    const r=new FileReader();
    r.onload=()=>{
      try{
        const state=JSON.parse(r.result);
        if(!confirm('Importar backup reemplazar√° tus datos actuales. ¬øContinuar?')) return;
        applyBackupState(state);
        alert('Backup importado.');
        renderAll();
      }catch(e){ alert('Backup inv√°lido o corrupto.'); }
    };
    r.readAsText(file);
    ev.target.value='';
  });



  // Stats modal (detalle d√©ficit/adherencia)
  function bindStatsModal(){
    const openBtn = $('openStats');
    const openBtnTop = $('openStatsTop');
    const modal = $('statsModal');
    const closeBtn = $('closeStats');
    const open = ()=>{ if(!modal) return; modal.style.display='block'; renderStatsModal(); };
    if(openBtn) openBtn.onclick = open;
    if(openBtnTop) openBtnTop.onclick = open;
    if(closeBtn) closeBtn.onclick = ()=>{ if(modal) modal.style.display='none'; };
    if(modal) modal.onclick = (e)=>{ if(e.target===modal) modal.style.display='none'; };
  }

  function renderStatsModal(){
    try{
      $('statDef7').textContent = $('def7Val')?.textContent ?? '‚Äî';
      $('statDef15').textContent = $('def15Val')?.textContent ?? '‚Äî';
      $('statDef30').textContent = $('def30Val')?.textContent ?? '‚Äî';
      $('statAdh7').textContent = $('adh7Val')?.textContent ?? '‚Äî';
      $('statAdh15').textContent = $('adh15Val')?.textContent ?? '‚Äî';
      $('statAdh30').textContent = $('adh30Val')?.textContent ?? '‚Äî';

      const dev = computeDeficitDeviation(loadProfile(), loadMode());
      if(!dev){
        $('statDevText').textContent = 'A√∫n no hay suficientes d√≠as cerrados con registro.';
        const dotEl = $('statDevDot'); if(dotEl) dotEl.className = 'dot ok';
        return;
      }
      const pct = Math.round(dev.deviation*100);
      let msg = `En 7 d√≠as: real ${Math.round(dev.real)} kcal vs plan ${Math.round(dev.planned)} kcal. Desviaci√≥n ${pct}%.`;
      let dot = 'ok';
      if(Math.abs(dev.deviation) <= 0.10){ dot='good'; msg += ' Dentro de rango.'; }
      else if(Math.abs(dev.deviation) <= 0.20){ dot='ok'; msg += ' Ajuste suave recomendado.'; }
      else { dot='bad'; msg += ' Ajuste recomendado para corregir rumbo.'; }

      const dotEl = $('statDevDot'); if(dotEl) dotEl.className = 'dot '+dot;

      const correction = Math.round((dev.planned - dev.real)/5);
      msg += ` Correcci√≥n sugerida: ${correction>0?'+':''}${correction} kcal/d√≠a durante 5 d√≠as.`;
      $('statDevText').textContent = msg;
    }catch(e){
      console.error(e);
      const t = $('statDevText'); if(t) t.textContent = 'Error al calcular estad√≠sticas: ' + (e?.message||e);
      const dotEl = $('statDevDot'); if(dotEl) dotEl.className = 'dot bad';
    }
  }


  // Service Worker (actualizaci√≥n agresiva)
  if('serviceWorker' in navigator){
    window.addEventListener('load', async ()=>{
      try{
        const reg = await navigator.serviceWorker.register('sw.js',{ updateViaCache: 'none' }).then(r=>{ try{ r.update(); }catch(e){} });
        if(reg.waiting) reg.waiting.postMessage({type:'SKIP_WAITING'});

        reg.addEventListener('updatefound', ()=>{
          const nw = reg.installing;
          if(!nw) return;
          nw.addEventListener('statechange', ()=>{
            if(nw.state==='installed' && navigator.serviceWorker.controller){
              nw.postMessage({type:'SKIP_WAITING'});
            }
          });
        });

        navigator.serviceWorker.addEventListener('controllerchange', ()=>{
          window.location.reload();
        });
      }catch(e){}
    });
  }

  // Watcher medianoche
  setInterval(()=>{
    if(rolloverIfNeeded()){
      renderAll();
      alert('Nuevo d√≠a: registro reiniciado.');
    }
  }, 20000);


  // ===== Fase 1/2 UX helpers =====
  const RECENT_KEY='mc_recent_foods';
  const loadRecent=()=>{ try{return JSON.parse(localStorage.getItem(RECENT_KEY)||'[]');}catch{return [];} };
  const saveRecent=(arr)=>localStorage.setItem(RECENT_KEY, JSON.stringify(arr.slice(0,8)));
  const pushRecent=(id)=>{ if(!id) return; const a=loadRecent().filter(x=>x!==id); a.unshift(id); saveRecent(a); };

  const renderRecentFoods=(foods)=>{
    const box=$('recentFoods'); if(!box) return;
    const ids=loadRecent();
    const items=ids.map(id=>foodById(foods,id)).filter(Boolean);
    if(!items.length){ box.style.display='none'; box.innerHTML=''; return; }
    box.style.display='flex'; box.innerHTML='';
    items.forEach(f=>{
      const b=document.createElement('button');
      b.type='button'; b.className='chip'; b.textContent=f.name;
      b.onclick=()=>{ $('foodPick').value=f.id; applyQtyModeForFood(f); $('qty')?.focus(); };
      box.appendChild(b);
    });
  };

  const setUnitButtons=(mode)=>{
    const g=$('btnUnitG'), u=$('btnUnitU'); if(!g||!u) return;
    g.classList.toggle('active', mode==='g');
    u.classList.toggle('active', mode==='unit');
  };

  const applyQtyModeForFood=(f)=>{
    if(!f) return;
    const hasUnit = (f.unitGrams!==null && f.unitGrams!==undefined);
    const mode = hasUnit ? 'unit' : 'g';
    $('qtyType').value = mode;
    setUnitButtons(mode);
    // bloqueo total + UX: ocultar el bot√≥n que no aplica
    const g=$('btnUnitG'), u=$('btnUnitU');
    if(g&&u){
      if(hasUnit){ g.style.display='none'; u.style.display='flex'; u.disabled=true; }
      else { u.style.display='none'; g.style.display='flex'; g.disabled=true; }
    }
    // defaults
    $('qty').value = hasUnit ? '1' : '100';
  };

  // Mantener coherencia al cambiar selecci√≥n
  $('foodPick')?.addEventListener('change', ()=>{
    const foods=loadFoodsMerged();
    const f=foodById(foods,$('foodPick').value);
    if(f) applyQtyModeForFood(f);
  });

  // Guardar recientes al a√±adir
  const _addItem = $('addItem')?.onclick;
  if(_addItem){
    $('addItem').onclick=()=>{
      const foods=loadFoodsMerged();
      const f=foodById(foods,$('foodPick').value);
      _addItem();
      if(f) pushRecent(f.id);
      renderRecentFoods(loadFoodsMerged());
    };
  }
  // ===== Fase 1/2 UX helpers =====

  // Init
  migrateIfNeeded();
  ensureFoodsStores();
  rolloverIfNeeded();
  bindDevLongPress();
  bindDevOCR();
  applyDevUI();

  // Panel plegable Macros OK (recordar estado)
  const _macPanel = $('macrosOkPanel');
  if(_macPanel){
    _macPanel.open = localStorage.getItem('mc_ui_macrosOkOpen') === '1';
    _macPanel.addEventListener('toggle', ()=>{
      localStorage.setItem('mc_ui_macrosOkOpen', _macPanel.open ? '1' : '0');
    });
  }

  renderAll();
})();
// ===== Daily Ledger System (90 days) =====
const LEDGER_KEY = 'mc_daily_ledger';
const LEDGER_LIMIT = 90;

function loadLedger(){
  return JSON.parse(localStorage.getItem(LEDGER_KEY) || "[]");
}

function saveLedger(data){
  localStorage.setItem(LEDGER_KEY, JSON.stringify(data));
}

function addDayToLedger(summary){
  let ledger = loadLedger();
  ledger = ledger.filter(d => d.dateKey !== summary.dateKey);
  ledger.push(summary);
  ledger.sort((a,b)=> a.dateKey.localeCompare(b.dateKey));
  if(ledger.length > LEDGER_LIMIT){
    ledger = ledger.slice(-LEDGER_LIMIT);
  }
  saveLedger(ledger);
}

// Call this when day closes or when renderAll runs on past day
function freezeDayIfNeeded(dateKey, summary){
  const today = new Date().toISOString().slice(0,10);
  if(dateKey < today){
    addDayToLedger(summary);
  }
}
// ===== End Ledger System =====



// ======= r50 ENHANCED OCR PARSER (Per 100g + Serving/Unit Column Support) =======
// NOTE: App storage remains PER 100G (base 100g). Serving/Unit values are used for preview + validation only.
// Supported labels (ES/EN):
// - "por 100 g", "per 100 g", or standalone header "100 g"
// - "por unidad", "por raci√≥n", "per serving" + grams (e.g. "15 g", "125 g")
// - Dual-column tables like: "Grasas 47 g 7 g" (per 100g, per serving)

function _ocrNum(x){
  if(x==null) return null;
  const s=String(x).replace(/,/g,'.');
  const v=parseFloat(s);
  return Number.isFinite(v) ? v : null;
}

function extractUnitGramsFromText(text){
  // e.g. "por unidad (125 g)" or "por raci√≥n 125 g"
  const m = text.match(/(?:unidad|raci[o√≥]n|serving)[^\d]*(\d+(?:[.,]\d+)?)\s*g/i);
  return m ? _ocrNum(m[1]) : null;
}

function extractServingGramsHeader(text){
  // Try to detect a dual header like "100 g ... 15 g" -> serving=15g
  const norm = text.replace(/,/g,'.');
  const all = [...norm.matchAll(/\b(\d+(?:\.\d+)?)\s*g\b/gi)].map(m=>_ocrNum(m[1])).filter(v=>v!=null);
  // If both 100g and another grams value exist, pick the first value !=100 as serving grams
  if(all.length>=2){
    const other = all.find(v=>Math.abs(v-100)>0.01);
    if(other) return other;
  }
  return null;
}

function detectBaseType(text){
  const norm = text.toLowerCase().replace(/,/g,'.');
  const per100Phrase = /por\s*100\s*g|per\s*100\s*g/.test(norm);
  const perUnitPhrase = /(por\s+unidad|por\s+raci[o√≥]n|per\s+serving)/.test(norm);

  // accept standalone header "100 g" near the top (common on EU labels)
  const headerSlice = norm.slice(0, 220);
  const has100gHeader = /\b100\s*g\b/.test(headerSlice);

  const unitGrams = extractUnitGramsFromText(text);
  const servingGrams = extractServingGramsHeader(text) || unitGrams;

  return {
    per100g: per100Phrase || has100gHeader,
    perUnit: perUnitPhrase,
    unitGrams,
    servingGrams
  };
}

function convertUnitTo100g(macros, unitGrams){
  const factor = 100 / unitGrams;
  return {
    fat: macros.fat * factor,
    protein: macros.protein * factor,
    carbs: macros.carbs * factor,
    kcal: macros.kcal!=null ? macros.kcal * factor : null
  };
}

function parseLineDualValue(normText, keywordRegex){
  const lines = normText.split(/\r?\n/);
  for(const ln of lines){
    if(keywordRegex.test(ln)){
      const nums = [...ln.matchAll(/(\d+(?:\.\d+)?)/g)].map(m=>_ocrNum(m[1])).filter(v=>v!=null);
      if(nums.length>=1){
        return { v1: nums[0], v2: (nums.length>=2 ? nums[1] : null), rawLine: ln };
      }
    }
  }
  return { v1:null, v2:null, rawLine:null };
}

function parseNutritionTextEnhanced(text){
  const norm = text.replace(/,/g, '.');
  const baseInfo = detectBaseType(text);

  const fatLine = parseLineDualValue(norm, /grasas?|fat\b/i);
  const proteinLine = parseLineDualValue(norm, /prote[i√≠]nas?|protein\b/i);
  const carbLine = parseLineDualValue(norm, /hidratos|carbohidratos|carbohydrate|carbs?\b/i);
  const kcalLine = parseLineDualValue(norm, /(kcal|energ[√≠i]a)/i);

  let fat = fatLine.v1, protein = proteinLine.v1, carbs = carbLine.v1;
  let kcal = kcalLine.v1;

  if(fat==null) fat = _ocrNum((norm.match(/grasas?[^\d]*(\d+(?:\.\d+)?)/i)||[])[1]);
  if(protein==null) protein = _ocrNum((norm.match(/prote[i√≠]nas?[^\d]*(\d+(?:\.\d+)?)/i)||[])[1]);
  if(carbs==null) carbs = _ocrNum((norm.match(/hidratos[^\d]*(\d+(?:\.\d+)?)/i)||[])[1]) 
                    ?? _ocrNum((norm.match(/carb(?:ohidratos)?[^\d]*(\d+(?:\.\d+)?)/i)||[])[1])
                    ?? _ocrNum((norm.match(/carbohydrates?[^\d]*(\d+(?:\.\d+)?)/i)||[])[1]);
  if(kcal==null) kcal = _ocrNum((norm.match(/(\d+(?:\.\d+)?)\s*kcal/i)||[])[1]);

  if(fat==null || protein==null || carbs==null) return null;

  const serving = {
    grams: baseInfo.servingGrams || null,
    fat: fatLine.v2,
    protein: proteinLine.v2,
    carbs: carbLine.v2,
    kcal: kcalLine.v2
  };

  let result = { fat, protein, carbs, kcal };

  if((!baseInfo.per100g) && baseInfo.perUnit && baseInfo.unitGrams){
    result = convertUnitTo100g(result, baseInfo.unitGrams);
    result._convertedFromUnit = true;
  }

  if(result.kcal==null){
    result.kcal = Math.round(result.fat*9 + (result.protein+result.carbs)*4);
    result._kcalEstimated = true;
  } else {
    result.kcal = Math.round(result.kcal);
  }

  result._baseInfo = baseInfo;
  result._serving = serving;
  return result;
}
// ======= END r50 OCR ENHANCEMENT =======

</script>

  <!-- Trace Modal (DEV) -->
  <div id="traceModal" style="display:none;position:fixed;inset:0;z-index:60;background:rgba(0,0,0,.55);padding:calc(env(safe-area-inset-top) + 16px) 16px calc(env(safe-area-inset-bottom) + 16px) 16px;">
    <div class="card" style="max-width:820px;margin:40px auto 0;position:relative;">
      <button id="closeTrace" class="delBtn" type="button" style="position:absolute;top:12px;right:12px;">Cerrar</button>
      <h1 style="margin:0 0 6px;">Trace: Cuadrar D√≠a</h1>
      <div class="muted">Esto muestra por qu√© la app eligi√≥ cada alimento (candidatos, caps, aprendizaje y resultado).</div>
      <label>JSON</label>
      <textarea id="traceText" spellcheck="false" style="min-height:260px;"></textarea>
      <div class="seg" style="margin-top:8px;">
        <button id="copyTrace" type="button">Copiar</button>
      </div>
    </div>
  </div>

</body>
</html>